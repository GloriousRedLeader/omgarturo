# Razor Enhanced Scripts for Ultima Online by
#   GRL  
#   https://github.com/GloriousRedLeader/omgarturo
#   2025-09-17
# Use at your own risk. 
#
# This file was auto-generated by the import inliner.
# Original dependencies from fm_core have been inlined below.

# ===============================================
# External Imports
# ===============================================
from System import DateTime, AppDomain
import System.IO as IO
import clr
import re

# ===============================================
# Main Script Code
# ===============================================
# ---------- WinForms ----------
try:
    clr.AddReference('System.Windows.Forms')
    clr.AddReference('System.Drawing')
    from System.Windows.Forms import (Application, Form, Label, TextBox, Button,
                                      RadioButton, CheckBox,
                                      FormBorderStyle, MessageBox, FormStartPosition,
                                      FlowLayoutPanel, TabControl, TabPage)
    from System.Drawing import Point, Size, Color, Font, FontStyle
    HAS_FORMS = True
except Exception:
    HAS_FORMS = False

# ---------- Config ----------
RECURSE_SUBCONTAINERS = True
WAIT_PROPS_MS = 1500
WAIT_CONTENT_MS = 1500

SKIP_RECURSE_NAME_CONTAINS = [
    'bulk order deed', 'bod', 'quiver', 'spellbook', 'songbook', 'book of'
]

TILE_W, TILE_H = 132, 26
DQ = chr(34)

FORCED_CONTAINER_ITEMIDS = {0x9F1C, 0xA5E9}
FORCED_CONTAINER_NAMES = {'jewelry box','shelves'}

def is_actual_container(itm):
    if bool(getattr(itm, 'IsContainer', False)): return True
    if int(getattr(itm, 'ItemID', 0)) in FORCED_CONTAINER_ITEMIDS: return True
    nm = (getattr(itm, 'Name','') or '').strip().lower()
    if nm in FORCED_CONTAINER_NAMES: return True
    return False

# ---------- IO helpers ----------

def textify(v):
    try:
        if v is None: return ''
        return v if isinstance(v, str) else str(v)
    except Exception:
        return ''

def csv_escape(v):
    s = textify(v)
    return DQ + s.replace(DQ, DQ + DQ) + DQ

def try_write(path, line, quiet=True):
    t = textify(line)
    if t.endswith('\r\n') or t.endswith('\n'):
        t = t.rstrip('\r\n')
    ok = Misc.AppendToFile(path, t)
    if not ok and not quiet:
        Misc.SendMessage('Failed writing line to: {0}'.format(path), 33)
    return ok

def ensure_dir(path):
    try:
        if not IO.Directory.Exists(path):
            IO.Directory.CreateDirectory(path)
        return True
    except Exception:
        return False

# ---------- Output path (unique per minute) ----------
OUTPUT_DIRS = [r'Data', r'Exports', r'C:/CUO/Data', r'C:/ClassicUO/Data']

def preferred_logs_dir():
    base = AppDomain.CurrentDomain.BaseDirectory
    for d in [IO.Path.Combine(base, 'Razor', 'Scripts', 'Container Logs'),
              IO.Path.Combine(base, 'Scripts', 'Container Logs'),
              IO.Path.Combine(base, 'RazorEnhanced', 'Scripts', 'Container Logs')]:
        if ensure_dir(d):
            probe = IO.Path.Combine(d, 'probe.txt')
            if try_write(probe, 'probe', quiet=True):
                Misc.DeleteFile(probe)
                return d
    return None

def candidate_dirs(user_dirs):
    dirs = list(user_dirs)
    try:
        root = AppDomain.CurrentDomain.BaseDirectory
        dirs.append(IO.Path.Combine(root, 'Data'))
        dirs.append(IO.Path.Combine(root, 'Exports'))
    except Exception:
        pass
    seen = set(); out = []
    for d in dirs:
        if d not in seen:
            seen.add(d); out.append(d)
    return out

def next_unique_path(path):
    try:
        if not IO.File.Exists(path):
            return path
        folder = IO.Path.GetDirectoryName(path)
        base = IO.Path.GetFileNameWithoutExtension(path)
        ext = IO.Path.GetExtension(path)
        for i in range(2, 500):
            alt = IO.Path.Combine(folder, base + '_' + str(i) + ext)
            if not IO.File.Exists(alt):
                return alt
    except Exception:
        pass
    return path

def resolve_output_path():
    stamp = DateTime.Now.ToString('yyyy-MM-dd_Hmm')
    pref = preferred_logs_dir()
    if pref is not None:
        return next_unique_path(IO.Path.Combine(pref, 'ItemScan_{0}.csv'.format(stamp)))
    probe_name = 'RE_write_probe_{0}.csv'.format(stamp)
    for base in candidate_dirs(OUTPUT_DIRS):
        if not ensure_dir(base):
            continue
        probe = IO.Path.Combine(base, probe_name)
        if try_write(probe, 'probe', quiet=True):
            Misc.DeleteFile(probe)
            return next_unique_path(IO.Path.Combine(base, 'ItemScan_{0}.csv'.format(stamp)))
    return None

# ---------- UO helpers ----------
NUM_RE = re.compile(r'[-+]?\d+')

ALIAS = {
    # Acronyms and core
    'hci': 'HCI', 'dci': 'DCI', 'ssi': 'SSI', 'di': 'DI', 'sdi': 'SDI',
    'hit chance increase': 'HCI',
    'defense chance increase': 'DCI',
    'swing speed increase': 'SSI',
    'damage increase': 'DI',
    'spell damage increase': 'SDI',
    'faster cast recovery': 'Faster Cast Recovery',
    'faster casting recovery': 'Faster Cast Recovery',
    'fcr': 'Faster Cast Recovery',
    'faster casting': 'Faster Casting',
    'fc': 'Faster Casting',
    'lower mana cost': 'Lower Mana Cost', 'lmc': 'Lower Mana Cost',
    'lower reagent cost': 'Lower Reagent Cost', 'lrc': 'Lower Reagent Cost',
    'enhance potions': 'Enhance Potions', 'enhanced potions': 'Enhance Potions', 'ep': 'Enhance Potions',
    'luck': 'Luck',
    # -------------------- Skill synonyms (full + shorthand + "Skill:" prefix) --------------------
    'alchemy': 'Alchemy', 'skill: alchemy': 'Alchemy',
    'anatomy': 'Anatomy', 'skill: anatomy': 'Anatomy',
    'animal lore': 'Animal Lore', 'skill: animal lore': 'Animal Lore',
    'item identification': 'Item Identification', 'item id': 'Item Identification', 'skill: item identification': 'Item Identification', 'skill: item id': 'Item Identification',
    'arms lore': 'Arms Lore', 'skill: arms lore': 'Arms Lore',
    'parry': 'Parry', 'parrying': 'Parry', 'skill: parry': 'Parry',
    'begging': 'Begging', 'skill: begging': 'Begging',
    'blacksmithing': 'Blacksmithing', 'blacksmith': 'Blacksmithing', 'skill: blacksmithing': 'Blacksmithing',
    'bowcraft/fletching': 'Bowcraft/Fletching', 'bowcraft': 'Bowcraft/Fletching', 'fletching': 'Bowcraft/Fletching', 'skill: bowcraft/fletching': 'Bowcraft/Fletching',
    'peacemaking': 'Peacemaking', 'skill: peacemaking': 'Peacemaking',
    'camping': 'Camping', 'skill: camping': 'Camping',
    'carpentry': 'Carpentry', 'skill: carpentry': 'Carpentry',
    'cartography': 'Cartography', 'skill: cartography': 'Cartography',
    'cooking': 'Cooking', 'skill: cooking': 'Cooking',
    'detect hidden': 'Detect Hidden', 'detecting hidden': 'Detect Hidden', 'skill: detect hidden': 'Detect Hidden',
    'discordance': 'Discordance', 'skill: discordance': 'Discordance',
    'evaluating intelligence': 'Evaluating Intelligence', 'eval int': 'Evaluating Intelligence', 'skill: evaluating intelligence': 'Evaluating Intelligence', 'skill: eval int': 'Evaluating Intelligence',
    'healing': 'Healing', 'skill: healing': 'Healing',
    'fishing': 'Fishing', 'skill: fishing': 'Fishing',
    'forensic evaluation': 'Forensic Evaluation', 'skill: forensic evaluation': 'Forensic Evaluation',
    'herding': 'Herding', 'skill: herding': 'Herding',
    'hiding': 'Hiding', 'skill: hiding': 'Hiding',
    'provocation': 'Provocation', 'provoke': 'Provocation', 'skill: provocation': 'Provocation',
    'inscription': 'Inscription', 'skill: inscription': 'Inscription',
    'lockpicking': 'Lockpicking', 'lock picking': 'Lockpicking', 'skill: lockpicking': 'Lockpicking',
    'magery': 'Magery', 'skill: magery': 'Magery',
    'magic resist': 'Magic Resist', 'resisting spells': 'Magic Resist', 'resist spells': 'Magic Resist', 'skill: magic resist': 'Magic Resist', 'skill: resisting spells': 'Magic Resist',
    'tactics': 'Tactics', 'skill: tactics': 'Tactics',
    'snooping': 'Snooping', 'skill: snooping': 'Snooping',
    'musicianship': 'Musicianship', 'skill: musicianship': 'Musicianship',
    'poisoning': 'Poisoning', 'skill: poisoning': 'Poisoning',
    'archery': 'Archery', 'skill: archery': 'Archery',
    'spirit speak': 'Spirit Speak', 'spiritspeak': 'Spirit Speak', 'skill: spirit speak': 'Spirit Speak',
    'stealing': 'Stealing', 'skill: stealing': 'Stealing',
    'tailoring': 'Tailoring', 'skill: tailoring': 'Tailoring',
    'animal taming': 'Animal Taming', 'skill: animal taming': 'Animal Taming',
    'taste identification': 'Taste Identification', 'taste id': 'Taste Identification', 'skill: taste identification': 'Taste Identification', 'skill: taste id': 'Taste Identification',
    'tinkering': 'Tinkering', 'skill: tinkering': 'Tinkering',
    'tracking': 'Tracking', 'skill: tracking': 'Tracking',
    'veterinary': 'Veterinary', 'skill: veterinary': 'Veterinary',
    'swordsmanship': 'Swordsmanship', 'swords': 'Swordsmanship', 'skill: swordsmanship': 'Swordsmanship', 'skill: swords': 'Swordsmanship',
    'mace fighting': 'Mace Fighting', 'macing': 'Mace Fighting', 'macefighting': 'Mace Fighting', 'skill: mace fighting': 'Mace Fighting', 'skill: macing': 'Mace Fighting',
    'fencing': 'Fencing', 'skill: fencing': 'Fencing',
    'wrestling': 'Wrestling', 'skill: wrestling': 'Wrestling',
    'lumberjacking': 'Lumberjacking', 'lumber jacking': 'Lumberjacking', 'skill: lumberjacking': 'Lumberjacking',
    'mining': 'Mining', 'skill: mining': 'Mining',
    'meditation': 'Meditation', 'skill: meditation': 'Meditation',
    'stealth': 'Stealth', 'skill: stealth': 'Stealth',
    'remove trap': 'Remove Trap', 'remove traps': 'Remove Trap', 'skill: remove trap': 'Remove Trap',
    'necromancy': 'Necromancy', 'necro': 'Necromancy', 'skill: necromancy': 'Necromancy',
    'focus': 'Focus', 'skill: focus': 'Focus',
    'chivalry': 'Chivalry', 'chiv': 'Chivalry', 'skill: chivalry': 'Chivalry',
    'bushido': 'Bushido', 'skill: bushido': 'Bushido',
    'ninjitsu': 'Ninjitsu', 'ninja': 'Ninjitsu', 'skill: ninjitsu': 'Ninjitsu',
    'spellweaving': 'Spellweaving', 'spell weaving': 'Spellweaving', 'skill: spellweaving': 'Spellweaving',
    'mysticism': 'Mysticism', 'skill: mysticism': 'Mysticism',
    'imbuing': 'Imbuing', 'skill: imbuing': 'Imbuing',
    'throwing': 'Throwing', 'skill: throwing': 'Throwing',


    # -------------------- Extra non-skill synonyms (completeness) --------------------
    'elves only': 'Elves Only', 'elf only': 'Elves Only',
    'gargoyles only': 'Gargoyles Only', 'gargoyle only': 'Gargoyles Only',
    'casting focus': 'Casting Focus', 'cast focus': 'Casting Focus',
    'mana regen': 'mana regen', 'stam regen': 'stam regen', 'hp regen': 'HP regen',

    # Stats / regens aliases
    'hit point increase': 'HP increase',
    'stamina increase': 'Stamina Increase',
    'mana increase': 'Mana increase',
    'hit point regeneration': 'HP regen',
    'stamina regeneration': 'stam regen',
    'mana regeneration': 'mana regen',
    'strength bonus': 'STR bonus',
    'dexterity bonus': 'DEX bonus',
    'intelligence bonus': 'INT bonus',
    # Hit effects
    'hit magic arrow': 'Hit Magic Arrow',
    'hit harm': 'Hit Harm',
    'hit fireball': 'Hit Fireball',
    'hit lightning': 'Hit Lightning',
    'hit dispel': 'Hit Dispel',
    'hit curse': 'Hit Curse',
    'hit life leech': 'Hit Life Leech',
    'hit mana leech': 'Hit Mana Leech',
    'hit stamina leech': 'Hit Stamina Leech',
    'hit cold area': 'Hit Cold Area',
    'hit fire area': 'Hit Fire Area',
    'hit poison area': 'Hit Poison Area',
    'hit energy area': 'Hit Energy Area',
    'hit physical area': 'Hit Physical Area',
    'hit lower attack': 'Hit Lower Attack',
    'hit lower defense': 'Hit Lower Defense',
    # Flags / utility
    'cursed': 'Cursed',
    'reflect physical damage': 'Reflect Physical Damage',
    'spell channeling': 'Spell Channeling',
    'night sight': 'Night Sight',
    'enhance damage': 'Enhance Damage',
    'enhance defense': 'Enhance Defense',
    'soul charge': 'Soul Charge', 'soul-charge': 'Soul Charge', 'soulcharge': 'Soul Charge', 'soul charge:': 'Soul Charge',
    # Reactives
    'reactive paralyze': 'Reactive Paralyze', 'reactive: paralyze': 'Reactive Paralyze',
    'reactive fireball': 'Reactive Fireball', 'reactive: fireball': 'Reactive Fireball',
    'reactive curse': 'Reactive Curse', 'reactive: curse': 'Reactive Curse',
    'reactive lightning': 'Reactive Lightning', 'reactive: lightning': 'Reactive Lightning',
    'reactive mana drain': 'Reactive Mana Drain', 'reactive: mana drain': 'Reactive Mana Drain',
    # Damages splits
    'physical damage': 'Physical Damage',
    'cold damage': 'Cold Damage',
    'fire damage': 'Fire Damage',
    'poison damage': 'Poison Damage',
    'energy damage': 'Energy Damage',
    # Resists
    'physical resist': 'Physical Resist',
    'cold resist': 'Cold Resist',
    'fire resist': 'Fire Resist',
    'poison resist': 'Poison Resist',
    'energy resist': 'Energy Resist',
}


def normalize_header(name):
    raw = textify(name).strip(); low = raw.lower()
    return ALIAS.get(low, raw)


def ensure_container_open(container_item):
    Items.UseItem(container_item)
    Items.WaitForContents(container_item, WAIT_CONTENT_MS)
    Misc.Pause(200)


def get_props_list(item):
    Items.WaitForProps(item, WAIT_PROPS_MS)
    try:
        props = Items.GetPropStringList(item)
    except Exception:
        props = []
    return props or []


def get_container_meta(itm):
    name = textify(getattr(itm, 'Name', 'Container'))
    engr = ''
    try:
        props = get_props_list(itm)
        for line in props:
            if not line: continue
            low = line.lower()
            if 'engraved' in low:
                # common: "Engraved: <text>"
                if ':' in line:
                    engr = line.split(':',1)[1].strip()
                else:
                    # fallback: take text after the word
                    idx = low.find('engraved')
                    engr = line[idx+8:].strip(' -:')
                break
    except Exception:
        pass
    return name, engr


def should_recurse_into(itm):
    if not is_actual_container(itm):
        return False
    nm = textify(getattr(itm, 'Name', '')).lower()
    for token in SKIP_RECURSE_NAME_CONTAINS:
        if token in nm:
            return False
    return True


def count_immediate_items(container_item):
    try:
        ensure_container_open(container_item)
        return len(list(container_item.Contains)) if getattr(container_item, 'Contains', None) is not None else 0
    except Exception:
        return 0


def parse_prop_line(line, item_name=None):
    t = textify(line)
    if not t:
        return None
    s = t.strip().replace('%', '').replace('+', '').rstrip(':')
    low = s.lower()

    if 'requirement' in low or 'required' in low:
        return None
    if item_name and s.lower() == textify(item_name).lower():
        return None

    if 'artifact' in low:
        for tier in ('legendary', 'major', 'greater', 'lesser', 'minor'):
            if tier in low:
                return ('Artifact', tier.capitalize())
        return ('Artifact', 'Artifact')
    if 'magic item' in low:
        for tier in ('major', 'greater', 'lesser', 'minor'):
            if tier in low:
                return ('Magic Item', tier.capitalize())
        return ('Magic Item', 'Magic Item')

    if 'slayer' in low or low == 'silver':
        return (s, s)

    m = NUM_RE.search(s)
    if m:
        name = s[:m.start()].strip()
        val = s[m.start():].strip()
        nums = NUM_RE.findall(val)
        if nums:
            try:
                return (normalize_header(name), int(nums[0]))
            except Exception:
                return (normalize_header(name), val)

    return (normalize_header(s), 'x')


def item_matches(props, wanted, mode):
    if not wanted:
        return False
    lows = [p.lower() for p in props]
    def has_attr(a):
        a = textify(a).lower()
        for p in lows:
            if a in p:
                return True
        return False
    if mode == 'ANY':
        return any(has_attr(a) for a in wanted)
    for a in wanted:
        if not has_attr(a):
            return False
    return True

# ---------- Traversal + collect per root ----------

def traverse_and_collect(root_item, root_name, root_engraving, recurse, wanted_attrs, match_mode, included_serials_global):
    rows = []  # (item_name, prop_map, root_name, root_engraving)
    stack = [(root_item, None, 'enter')]
    visited = set()

    while stack:
        itm, parent, phase = stack.pop()
        if itm is None:
            continue

        if phase == 'enter':
            if itm.Serial in visited:
                continue
            visited.add(itm.Serial)

            props_raw = [textify(p).strip() for p in get_props_list(itm) if textify(p).strip()]
            if item_matches(props_raw, wanted_attrs, match_mode):
                if itm.Serial not in included_serials_global:
                    pmap = {}
                    for pr in props_raw:
                        res = parse_prop_line(pr, item_name=getattr(itm, 'Name', ''))
                        if not res:
                            continue
                        key, val = res
                        if key not in (set(sum([CATEGORIES[c] for c in CATEGORY_ORDER], [])) | set(['Artifact','Magic Item'])): Misc.AppendToFile(IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory,'unknown_props.txt'), DateTime.Now.ToString('yyyy-MM-dd HH:mm:ss ') + key)
                        prev = pmap.get(key)
                        if isinstance(val, int) and isinstance(prev, int):
                            if val > prev:
                                pmap[key] = val
                        else:
                            if prev is None:
                                pmap[key] = val
                    name = textify(getattr(itm, 'Name', ''))
                    rows.append((name, pmap, root_name, root_engraving))
                    included_serials_global.add(itm.Serial)

            if recurse and should_recurse_into(itm):
                try:
                    ensure_container_open(itm)
                    children = list(itm.Contains) if getattr(itm, 'Contains', None) is not None else []
                except Exception:
                    children = []
                stack.append((itm, parent, 'exit'))
                for child in children:
                    stack.append((child, itm.Serial, 'enter'))
        else:
            try:
                cnt = count_immediate_items(itm)
            except Exception:
                cnt = 0
            cname = textify(getattr(itm, 'Name', 'Container'))
            Misc.SendMessage('Scanned {0} [{1}] items...'.format(cname, cnt), 88)

    return rows

# ---------- Categories ----------
CATEGORIES = {
    'Quality': ['Artifact', 'Magic Item'],
    'Core': [
        'SDI','Enhance Potions','Faster Cast Recovery','Faster Casting','Lower Mana Cost','Lower Reagent Cost',
        'Luck','HCI','DCI','SSI','DI','Casting Focus','Reflect Physical Damage',
        'Enhance Damage','Enhance Defense','Soul Charge','Spell Channeling','Night Sight'
    ],
    'Stats': ['STR bonus','DEX bonus','INT bonus','HP increase','Stamina Increase','Mana increase'],
    'Regens': ['HP regen','stam regen','mana regen'],
    'Hit Effects': [
        'Hit Magic Arrow','Hit Harm','Hit Fireball','Hit Lightning','Hit Dispel','Hit Curse',
        'Hit Life Leech','Hit Mana Leech','Hit Stamina Leech','Hit Cold Area','Hit Fire Area',
        'Hit Poison Area','Hit Energy Area','Hit Physical Area','Hit Lower Attack','Hit Lower Defense'
    ],
    'Damages': ['Physical Damage','Cold Damage','Fire Damage','Poison Damage','Energy Damage'],
    'Resists': ['Physical Resist','Cold Resist','Fire Resist','Poison Resist','Energy Resist'],
    'Eaters': ['Fire Eater','Cold Eater','Poison Eater','Energy Eater','Kinetic Eater','Damage Eater'],
    'Slayers': ['Demon Slayer','Undead Slayer','Reptile Slayer','Repond Slayer','Elemental Slayer','Fey Slayer','Arachnid Slayer','Silver'],
    'Skills': [
        'Alchemy','Anatomy','Animal Lore','Item Identification','Arms Lore','Parry','Begging','Blacksmithing','Bowcraft/Fletching',
        'Peacemaking','Camping','Carpentry','Cartography','Cooking','Detect Hidden','Discordance','Evaluating Intelligence','Healing',
        'Fishing','Forensic Evaluation','Herding','Hiding','Provocation','Inscription','Lockpicking','Magery','Magic Resist','Tactics',
        'Snooping','Musicianship','Poisoning','Archery','Spirit Speak','Stealing','Tailoring','Animal Taming','Taste Identification',
        'Tinkering','Tracking','Veterinary','Swordsmanship','Mace Fighting','Fencing','Wrestling','Lumberjacking','Mining','Meditation',
        'Stealth','Remove Trap','Necromancy','Focus','Chivalry','Bushido','Ninjitsu','Spellweaving','Mysticism','Imbuing','Throwing'
    ],
    'Flags': ['Cursed','Antique','Prized','Brittle','Elves Only','Gargoyles Only'],
    'Reactives': ['Reactive Paralyze','Reactive Fireball','Reactive Curse','Reactive Lightning','Reactive Mana Drain'],
}

CATEGORY_ORDER = list(CATEGORIES.keys())


def order_columns_by_category(found_cols):
    cols = []; seen = set()
    def push(x):
        if x in found_cols and x not in seen:
            seen.add(x); cols.append(x)
    for cat in CATEGORY_ORDER:
        for h in CATEGORIES[cat]:
            push(h)
    for h in sorted(found_cols):
        push(h)
    return cols

# ---------- UI ----------
if not HAS_FORMS:
    Misc.SendMessage('Windows Forms is not available. Cannot open the attribute panel.', 33)
else:
    class AttrFilterForm(Form):
        def __init__(self):
            Form.__init__(self)
            self.Text = 'Attribute Filter Exporter'
            self.Size = Size(760, 790)
            self.TopMost = True
            self.FormBorderStyle = FormBorderStyle.FixedDialog
            self.MinimizeBox = False
            self.MaximizeBox = False
            self.StartPosition = FormStartPosition.CenterScreen

            # Multi-container
            self.container_serials = []
            self.container_meta = {}  # serial -> (name, engraving)
            self.selected_set = set()

            y = 10
            self.lbl1 = Label(Text='Filter (current tab):')
            self.lbl1.Location = Point(10, y)
            self.lbl1.Width = 150
            self.Controls.Add(self.lbl1)

            self.search = TextBox(); self.search.Location = Point(160, y); self.search.Width = 380
            self.search.TextChanged += self.on_search
            self.Controls.Add(self.search)

            self.btn_all_tab = Button(Text='Select All (tab)')
            self.btn_all_tab.Location = Point(550, y-2); self.btn_all_tab.Width = 180
            self.btn_all_tab.Click += self.on_select_all
            self.Controls.Add(self.btn_all_tab)

            y += 34
            self.tabs = TabControl(); self.tabs.Location = Point(10, y); self.tabs.Size = Size(730, 560)
            self.tabs.SelectedIndexChanged += self.on_tab_changed
            self.Controls.Add(self.tabs)

            self.flows = {}
            for cat in CATEGORY_ORDER:
                tp = TabPage(); tp.Text = cat
                flow = FlowLayoutPanel(); flow.Location = Point(5, 5)
                flow.Size = Size(700, 520); flow.WrapContents = True; flow.AutoScroll = True
                tp.Controls.Add(flow)
                self.tabs.TabPages.Add(tp)
                self.flows[cat] = flow

            y += 565
            self.btn_all_tabs = Button(Text='Select All (ALL tabs)')
            self.btn_all_tabs.Location = Point(10, y-2); self.btn_all_tabs.Width = 180
            self.btn_all_tabs.Click += self.on_select_all_tabs
            self.Controls.Add(self.btn_all_tabs)

            self.btn_clear_tabs = Button(Text='Clear All')
            self.btn_clear_tabs.Location = Point(200, y-2); self.btn_clear_tabs.Width = 100
            self.btn_clear_tabs.Click += self.on_clear_all
            self.Controls.Add(self.btn_clear_tabs)

            self.rb_all = RadioButton(Text='Match ALL', Checked=False); self.rb_all.Location = Point(320, y)
            self.Controls.Add(self.rb_all)

            self.rb_any = RadioButton(Text='Match ANY', Checked=True)
            self.rb_any.Location = Point(self.rb_all.Location.X + 90, self.rb_all.Location.Y)
            self.Controls.Add(self.rb_any)

            self.btn_add_container = Button(Text='Add Container'); self.btn_add_container.Location = Point(560, y-2); self.btn_add_container.Width = 180
            self.btn_add_container.Click += self.on_add_container; self.Controls.Add(self.btn_add_container)

            # Remove Selected Container (target a container to remove it)
            self.btn_remove_container = Button(Text='Remove Container')
            self.btn_remove_container.Location = Point(self.btn_add_container.Location.X, self.btn_add_container.Location.Y + 28)
            self.btn_remove_container.Width = self.btn_add_container.Width
            self.btn_remove_container.Click += self.on_remove_container
            self.Controls.Add(self.btn_remove_container)

            y += 30
            self.chk_recurse = CheckBox(Text='Include subcontainers', Checked=RECURSE_SUBCONTAINERS)
            self.chk_recurse.Location = Point(10, y); self.Controls.Add(self.chk_recurse)

            self.chk_all_columns = CheckBox(Text='CSV: All properties', Checked=False)
            self.chk_all_columns.Location = Point(200, y); self.Controls.Add(self.chk_all_columns)

            self.chk_root_cols = CheckBox(Text='Container/Engraving', Checked=True)
            self.chk_root_cols.Location = Point(380, y); self.Controls.Add(self.chk_root_cols)

            self.btn_scan = Button(Text='Run Scan'); self.btn_scan.Location = Point(560, y+26); self.btn_scan.Width = 180
            self.btn_scan.Click += self.on_scan; self.Controls.Add(self.btn_scan)

            y += 30
            self.lbl_container = Label(Text='Containers: 0 selected')
            self.lbl_container.Location = Point(10, y)
            self.lbl_container.Width = 730
            self.Controls.Add(self.lbl_container)

            for cat in CATEGORY_ORDER:
                self.rebuild_tiles(cat, CATEGORIES[cat])

        # ---- tiles ----
        def make_tile(self, text):
            btn = Button(); btn.Text = text
            btn.AutoSize = False; btn.Size = Size(TILE_W, TILE_H)
            btn.Font = Font('Segoe UI', 8, FontStyle.Bold); btn.FlatStyle = 0
            btn.Tag = (text in self.selected_set); self.apply_tile_style(btn)
            def on_click(s, e):
                cur = bool(btn.Tag); btn.Tag = not cur
                if btn.Tag: self.selected_set.add(text)
                else: self.selected_set.discard(text)
                self.apply_tile_style(btn)
            btn.Click += on_click
            return btn

        def apply_tile_style(self, btn):
            if bool(btn.Tag):
                btn.BackColor = Color.FromArgb(130, 70, 180); btn.ForeColor = Color.White
            else:
                btn.BackColor = Color.FromArgb(235, 232, 248); btn.ForeColor = Color.FromArgb(60, 40, 80)

        def rebuild_tiles(self, cat, items):
            flow = self.flows[cat]; flow.Controls.Clear()
            for a in items: flow.Controls.Add(self.make_tile(a))

        def current_cat(self):
            return self.tabs.SelectedTab.Text

        # ---- handlers ----
        def on_search(self, sender, args):
            q = self.search.Text.lower().strip(); cat = self.current_cat(); base = CATEGORIES[cat]
            items = [a for a in base if (q in a.lower())] if q else base
            self.rebuild_tiles(cat, items)

        def on_select_all(self, sender, args):
            cat = self.current_cat()
            for a in CATEGORIES[cat]: self.selected_set.add(a)
            self.on_search(None, None)

        def on_select_all_tabs(self, sender, args):
            for cat in CATEGORY_ORDER:
                for a in CATEGORIES[cat]: self.selected_set.add(a)
            self.on_search(None, None)

        def on_clear_all(self, sender, args):
            self.selected_set.clear(); self.on_search(None, None)

        def on_tab_changed(self, sender, args):
            self.on_search(None, None)

        def on_add_container(self, sender, args):
            # Multi-pick: keep targeting until ESC. Avoid modal popups to prevent lockups.
            Misc.SendMessage('Target containers to ADD (ESC/Cancel to finish)', 945)
            while True:
                try:
                    serial = Target.PromptTarget('Add container (ESC to finish)')
                except Exception:
                    break
                if not serial:
                    break
                itm = Items.FindBySerial(serial)
                if not (itm and is_actual_container(itm)):
                    # Non-container (ground/tile) — treat as cancel to avoid modal loops
                    Misc.SendMessage('Not a container; finishing selection.', 33)
                    break
                if serial not in self.container_serials:
                    self.container_serials.append(serial)
                    self.container_meta[serial] = get_container_meta(itm)
                self.update_container_label()

        def update_container_label(self):
            names = []
            for s in self.container_serials:
                it = Items.FindBySerial(s)
                if it: names.append(textify(getattr(it, 'Name', 'Container')))
            if len(names) > 3:
                preview = ', '.join(names[:3]) + ' …'
            else:
                preview = ', '.join(names)
            self.lbl_container.Text = 'Containers: {0} selected{1}'.format(len(self.container_serials), (' — ' + preview) if preview else '')

        def on_remove_container(self, sender, args):
            Misc.SendMessage('Target a container to REMOVE', 33)
            try:
                serial = Target.PromptTarget('Remove container')
            except Exception:
                return
            if not serial:
                return
            if serial in self.container_serials:
                try:
                    self.container_serials.remove(serial)
                except Exception:
                    pass
                try:
                    if serial in self.container_meta:
                        del self.container_meta[serial]
                except Exception:
                    pass
                self.update_container_label()
                Misc.SendMessage('Removed container from selection.', 68)
            else:
                Misc.SendMessage('That container is not in the selection list.', 33)

        def on_scan(self, sender, args):
            selected = list(self.selected_set)
            if not selected:
                MessageBox.Show('Please select at least one attribute.')
                return
            if not self.container_serials:
                MessageBox.Show('Please add at least one container.')
                return
            mode = 'ALL' if self.rb_all.Checked else 'ANY'
            recurse = bool(self.chk_recurse.Checked)

            collected = []
            included_serials_global = set()
            # Refresh meta (name/engraving might change)
            for serial in list(self.container_serials):
                it = Items.FindBySerial(serial)
                if not it: 
                    continue
                self.container_meta[serial] = get_container_meta(it)
                name, engr = self.container_meta[serial]
                rows = traverse_and_collect(it, name, engr, recurse, selected, mode, included_serials_global)
                collected.extend(rows)

            if not collected:
                MessageBox.Show('No matching items found across selected containers.')
                return

            # Header (dynamic vs full)
            found_cols = set()
            for _name, pmap, _root, _engr in collected:
                for k in pmap:
                    found_cols.add(k)

            ordered_cols = []
            full = bool(self.chk_all_columns.Checked)
            for q in ('Artifact', 'Magic Item'):
                if full or q in found_cols:
                    ordered_cols.append(q)
                    if q in found_cols:
                        found_cols.remove(q)

            def all_props():
                s = set()
                for cat in CATEGORY_ORDER:
                    for h in CATEGORIES[cat]: s.add(h)
                for q in ('Artifact', 'Magic Item'):
                    if q in s: s.remove(q)
                return s

            ordered_cols += order_columns_by_category(all_props() if full else found_cols)

            base_cols = ['Name']
            if bool(self.chk_root_cols.Checked):
                base_cols += ['Container', 'Engraving']

            header = base_cols + ordered_cols
            out_path = resolve_output_path()
            if not out_path:
                MessageBox.Show('Cannot find a writable path. Please adjust OUTPUT_DIRS.')
                return
            if not try_write(out_path, ','.join([csv_escape(h) for h in header]), quiet=False):
                MessageBox.Show('Failed to write CSV header.')
                return

            for name, pmap, root_name, root_engr in collected:
                fixed = [name]
                if bool(self.chk_root_cols.Checked):
                    fixed += [root_name, root_engr]
                row = fixed + [pmap.get(col, '') for col in ordered_cols]
                line = ','.join([csv_escape(v) for v in row])
                if not try_write(out_path, line, quiet=False):
                    MessageBox.Show('Write failed. Aborting.')
                    return

            Misc.SendMessage('Export complete: {0} ({1} matching items across {2} container(s))'.format(out_path, len(collected), len(self.container_serials)), 68)

    try:
        Application.EnableVisualStyles(); form = AttrFilterForm(); Application.Run(form)
    except Exception as ex:
        Misc.SendMessage('UI error: {0}'.format(ex), 33)
