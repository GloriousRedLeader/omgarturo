# Razor Enhanced Scripts for Ultima Online by
#   GRL  
#   https://github.com/GloriousRedLeader/omgarturo
#   2025-09-17
# Use at your own risk. 
#
# This file was auto-generated by the import inliner.
# Original dependencies from fm_core have been inlined below.

# ===============================================
# External Imports
# ===============================================
from System import Byte, Int32
from System.Collections.Generic import List
from ctypes import wintypes
from pathlib import Path
import __main__
import ctypes
import inspect
import os
import re
import sys
import time

# ===============================================
# Inlined Dependencies (topologically sorted)
# ===============================================

# ANIMATE_DEAD_DELAY (from core_spells.py)
ANIMATE_DEAD_DELAY = 1750

# ANIMATE_DEAD_MOBILE_NAMES (from core_mobiles.py)
ANIMATE_DEAD_MOBILE_NAMES = [
    "a gore fiend",
    "a lich",
    "a flesh golem",
    "a mummy",
    "a skeletal dragon",
    "a lich lord",
    "a skeletal knight",
    "a bone knight",
    "a skeletal mage",
    "a bone mage",
    "a patchwork skeleton",
    "a mound of maggots",
    "a wailing banshee",
    "a wraith",
    "a hellsteed",
    "a skeletal steed",
    "an Undead Gargoyle",
    "a skeletal drake",
    "a putrid undead gargoyle",
    "a blade spirit",
    "an energy vortex",
    "a skeletal drake"
]

# ARCANE_EMPOWERMENT_DELAY (from core_spells.py)
ARCANE_EMPOWERMENT_DELAY = 3000

# ARCH_CURE_DELAY (from core_spells.py)
ARCH_CURE_DELAY = 1750

# ATTUNE_WEAPON_DELAY (from core_spells.py)
ATTUNE_WEAPON_DELAY = 1000

# BANDAGE_STATIC_ID (from core_items.py)
BANDAGE_STATIC_ID = 0x0E21

# BARD_SONG_DELAY (from core_spells.py)
BARD_SONG_DELAY = 2000

# BLOOD_OATH_DELAY (from core_spells.py)
BLOOD_OATH_DELAY = 1750

# CHAIN_LIGHTNING_DELAY (from core_spells.py)
CHAIN_LIGHTNING_DELAY = 2000

# CLOSE_WOUNDS_DELAY (from core_spells.py)
CLOSE_WOUNDS_DELAY = 1500

# CONDUIT_DELAY (from core_spells.py)
CONDUIT_DELAY = 2250

# CONSECRATE_WEAPON_DELAY (from core_spells.py)
CONSECRATE_WEAPON_DELAY = 500

# CORPSE_SKIN_DELAY (from core_spells.py)
CORPSE_SKIN_DELAY = 1750

# CURSE_DELAY (from core_spells.py)
CURSE_DELAY = 1750

# CURSE_WEAPON_DELAY (from core_spells.py)
CURSE_WEAPON_DELAY = 1000

# DEATH_RAY_DELAY (from core_spells.py)
DEATH_RAY_DELAY = 2250

# DIVINE_FURY_DELAY (from core_spells.py)
DIVINE_FURY_DELAY = 1000

# ENEMY_OF_ONE_DELAY (from core_spells.py)
ENEMY_OF_ONE_DELAY = 500

# ENERGY_BOLT_DELAY (from core_spells.py)
ENERGY_BOLT_DELAY = 2000

# EVIL_OMEN_DELAY (from core_spells.py)
EVIL_OMEN_DELAY = 1000

# FC_CAP_BARD_SONG (from core_spells.py)
FC_CAP_BARD_SONG = 4

# FC_CAP_CHIVALRY (from core_spells.py)
FC_CAP_CHIVALRY = 4

# FC_CAP_MAGERY (from core_spells.py)
FC_CAP_MAGERY = 2

# FC_CAP_NECROMANCY (from core_spells.py)
FC_CAP_NECROMANCY = 3 if (Player.GetSkillValue("Necromancy") == 120 and Player.GetSkillValue("Necromancy") == 120 and not any(Player.GetSkillValue(skill) > 30 for skill in ["Magery", "Spellweaving", "Parrying", "Mysticism", "Chivalry", "Animal Taming", "Animal Lore", "Ninjitsu", "Bushido", "Focus", "Imbuing", "Evaluating Intelligence"])) else 2

# FC_CAP_SHIELD_BASH (from core_spells.py)
FC_CAP_SHIELD_BASH = 4

# FC_CAP_SPELLWEAVING (from core_spells.py)
FC_CAP_SPELLWEAVING = 4

# FIRE_FIELD_DELAY (from core_spells.py)
FIRE_FIELD_DELAY = 1750

# FLAME_STRIKE_DELAY (from core_spells.py)
FLAME_STRIKE_DELAY = 2500

# GIFT_OF_LIFE_DELAY (from core_spells.py)
GIFT_OF_LIFE_DELAY = 4000

# GIFT_OF_RENEWAL_DELAY (from core_spells.py)
GIFT_OF_RENEWAL_DELAY = 3000

# GOLD_STATIC_IDS (from core_items.py)
GOLD_STATIC_IDS = [0x0EED]

# GREATER_HEAL_DELAY (from core_spells.py)
GREATER_HEAL_DELAY = 1750

# LAP_HARP_GRAPHIC_ID (from core_items.py)
LAP_HARP_GRAPHIC_ID = 0x0EB2

# MEDITATION_DELAY (from core_spells.py)
MEDITATION_DELAY = 1250

# PAIN_SPIKE_DELAY (from core_spells.py)
PAIN_SPIKE_DELAY = 1250

# POISON_DELAY (from core_spells.py)
POISON_DELAY = 1500

# POISON_FIELD_DELAY (from core_spells.py)
POISON_FIELD_DELAY = 2000

# POISON_STRIKE_DELAY (from core_spells.py)
POISON_STRIKE_DELAY = 2000

# PROTECTION_DELAY (from core_spells.py)
PROTECTION_DELAY = 750

# REMOVE_CURSE_DELAY (from core_spells.py)
REMOVE_CURSE_DELAY = 1500

# SHIELD_BASH_DELAY (from core_spells.py)
SHIELD_BASH_DELAY = 1000

# SPIRIT_SPEAK_DELAY (from core_spells.py)
SPIRIT_SPEAK_DELAY = 999

# STRANGLE_DELAY (from core_spells.py)
STRANGLE_DELAY = 2250 + 500

# SUMMON_FAMILIAR_DELAY (from core_spells.py)
SUMMON_FAMILIAR_DELAY = 2250

# THUNDERSTORM_DELAY (from core_spells.py)
THUNDERSTORM_DELAY = 1500

# VAMPIRIC_EMBRACE_DELAY (from core_spells.py)
VAMPIRIC_EMBRACE_DELAY = 2250

# WILDFIRE_DELAY (from core_spells.py)
WILDFIRE_DELAY = 2500

# WITHER_DELAY (from core_spells.py)
WITHER_DELAY = 2250

# WORD_OF_DEATH_DELAY (from core_spells.py)
WORD_OF_DEATH_DELAY = 3500

# WRAITH_FORM_DELAY (from core_spells.py)
WRAITH_FORM_DELAY = 2250

# find_all_in_container_by_ids (from core_player.py)
def find_all_in_container_by_ids(itemIDs, containerSerial = Player.Backpack.Serial):
    items = []
    for itemID in itemIDs:
        items = items + Items.FindAllByID(itemID, -1, containerSerial, 1)
    return items

# find_first_in_container_by_name (from core_player.py)
def find_first_in_container_by_name(itemName, containerSerial = Player.Backpack.Serial):
    return Items.FindByName(itemName, -1, containerSerial, 1)

# find_in_container_by_id (from core_player.py)
def find_in_container_by_id(itemID, containerSerial = Player.Backpack.Serial, color = -1, ignoreContainer = [], recursive = False):
    ignoreColor = False
    if color == -1:
        ignoreColor = True
        
    container = Items.FindBySerial(containerSerial)

    if isinstance( itemID, int ):
        foundItem = next( ( item for item in container.Contains if ( item.ItemID == itemID and ( ignoreColor or item.Hue == color ) ) ), None )
    elif isinstance( itemID, list ):
        foundItem = next( ( item for item in container.Contains if ( item.ItemID in itemID and ( ignoreColor or item.Hue == color ) ) ), None )
    else:
        raise ValueError( 'Unknown argument type for itemID passed to FindItem().', itemID, container )

    if foundItem != None:
        return foundItem        
    elif recursive == True:
        for item in container.Contains:
            if item.IsContainer:
                foundItem = find_in_container_by_id(itemID, containerSerial = item.Serial, color = color, ignoreContainer = ignoreContainer, recursive = recursive)
                if foundItem != None:
                    return foundItem

# get_blues_in_range (from core_mobiles.py)
def get_blues_in_range(range = 8):
    fil = Mobiles.Filter()
    fil.Enabled = True
    fil.RangeMax = range
    fil.Notorieties = List[Byte](bytes([1, 2]))
    fil.IsGhost = False
    fil.Friend = False
    fil.CheckLineOfSight = True
    mobs = Mobiles.ApplyFilter(fil)

    return mobs

# get_fc_delay (from core_spells.py)
def get_fc_delay (

    # Constants defined above for each spell
    baseDelayMs,
    
    # Each spell can have a different FC cap. Use constants above.
    fcCap,
    
    # Milliseonds of extra delay when computing cast time to account for internet fuzz. Fine tune this as needed.
    latencyMs = 200
):

    latency = 100
    fcOffset = 250 * (min(max(Player.FasterCasting - 2, 0), fcCap - 2) if Player.BuffsExist("Protection") else min(Player.FasterCasting, fcCap))
    delay = baseDelayMs - fcOffset
    if delay < 250:
        delay = 250
        
    #delay = delay + latencyMs
    #print("fc", Player.FasterCasting, "fcCap", fcCap, "protection", Player.BuffsExist("Protection"), "baseDelayMs", baseDelayMs, "fcOffset", fcOffset, "delay", delay)        
    return delay + latencyMs

# get_fcr_delay (from core_spells.py)
def get_fcr_delay(

    # Spell from Magery, Spellweaving, Necromancy, Chivalry
    spellName,  
    
    # Milliseonds of extra delay when computing cast time to account for internet fuzz. Fine tune this as needed.
    latencyMs = 200
):

    fcr = int(((6 - Player.FasterCastRecovery) / 4) * 1000)
        
    if fcr < 1:
        fcr = 1

    #print("FCR", "fcr", fcr)        
    return fcr + latencyMs

# get_friends_by_names (from core_mobiles.py)
def get_friends_by_names (friendNames = [], range = 8):
    fil = Mobiles.Filter()
    fil.Enabled = True
    fil.RangeMax = range
    fil.Notorieties = List[Byte](bytes([1, 2]))
    fil.IsGhost = False
    fil.Friend = False
    fil.CheckLineOfSight = True
    mobs = Mobiles.ApplyFilter(fil)

    #listValid = [m.Serial for m in mobs if m.Name in friendNames]

    if len(mobs) > 0:
        mobsList = List[type(mobs[0])]([mob for mob in mobs if mob.Name in friendNames])
        return mobsList    
    
    
    #if len(listValid) == 0:
    #    return []

    #fil = Mobiles.Filter()
    #fil.Enabled = True
    #for l in listValid:
    #    fil.Serials.Add(l)
    #fil.RangeMax = range
    #fil.Notorieties = List[Byte](bytes([1, 2]))
    #fil.IsGhost = False
    #fil.Friend = False
    #fil.CheckLineOfSight = True

    mobs = Mobiles.ApplyFilter(fil)

    return mobs

# get_mobile_percent_hp (from core_mobiles.py)
def get_mobile_percent_hp(mobile):
    if mobile is not None and mobile.Hits is not None and mobile.Hits > 0 and mobile.HitsMax is not None and mobile.HitsMax > 0:
        return mobile.Hits / mobile.HitsMax
    else:
        return 0

# get_pets (from core_mobiles.py)
def get_pets(range = 10, checkLineOfSight = True, mobileId = None):
    pets = []
    fil = Mobiles.Filter()
    fil.Enabled = True
    fil.RangeMax = range
    fil.Notorieties = List[Byte](bytes([1, 2]))
    fil.IsGhost = False
    fil.Friend = False
    fil.CheckLineOfSight = checkLineOfSight
    
    if mobileId is not None:
        fil.Bodies = List[Int32]([mobileId])
    
    blues = Mobiles.ApplyFilter(fil)    
    for blue in blues:
        if blue.CanRename:
            pets.append(blue)
    return pets

# user32 (from core_rails.py)
user32 = ctypes.WinDLL('user32', use_last_error=True)

# INSTRUMENT_STATIC_IDS (from core_items.py)
INSTRUMENT_STATIC_IDS = [ 
    0x0E9C, # drum
    0x2805, # flute
    0x0EB3, # lute
    LAP_HARP_GRAPHIC_ID, # lap harp
    0x0EB1, # standing harp
    0x0E9E, # tambourine
    0x0E9D, # tambourine (tassle)
]

# check_summon_familiar (from core_spells.py)
def check_summon_familiar(

    # Milliseonds of extra delay when computing cast time to account for internet fuzz. Fine tune this as needed.
    latencyMs = 200
):
    SUMMON_FAMILIAR_GUMP_ID = 0x2082496e
    
    if Timer.Check("checkSummonFamiliarTimer") == False:
        if not Gumps.HasGump(SUMMON_FAMILIAR_GUMP_ID):
            Spells.CastNecro("Summon Familiar")
            Gumps.WaitForGump(SUMMON_FAMILIAR_GUMP_ID, 1000)

        if Gumps.HasGump(SUMMON_FAMILIAR_GUMP_ID):
            petButtonMap = {}
            data = Gumps.GetGumpData(SUMMON_FAMILIAR_GUMP_ID)
            for piece in data.layoutPieces:
                match = re.match(r"button (?:\d+\s)*(\d+)", piece)
                if match is not None:
                    buttonId = int(match.group(1))
                    #print("buttonId! ", buttonId, type(buttonId))
                    if buttonId in [2, 102]:
                        petButtonMap["Shadow Wisp"] = buttonId
                    elif buttonId in [3, 103]:
                        petButtonMap["Dark Wol"] = buttonId
                    elif buttonId in [4, 104]:
                        petButtonMap["Death Adder"] = buttonId
                    elif buttonId in [5, 105]:
                        petButtonMap["Vampire Bat"] = buttonId

            pets = get_pets(range = 15, checkLineOfSight = False)
            petNames = [pet.Name.replace(Player.Name + " ", "") for pet in pets]    
            goodPetCount = 0
            connectionTooTenuous = False # Rare error where we need to reset all pets completely, dunno
            for petName in petButtonMap:
                
                # Summon a pet
                if petButtonMap[petName] < 6:
                    Journal.Clear()
                    Gumps.SendAction(SUMMON_FAMILIAR_GUMP_ID, petButtonMap[petName])
                    Misc.Pause(get_fc_delay (baseDelayMs = SUMMON_FAMILIAR_DELAY, fcCap = FC_CAP_NECROMANCY, latencyMs = latencyMs))
                    Misc.Pause(250) # Extra pause for create to appear in world or we get stuck in an infinite loop

                    # Summon failed. Need to unsummon all pets (below)
                    if Journal.Search("Your connection to the netherworld") == True:
                        connectionTooTenuous = True
                        break
                    return True
                    
                # Unsummon pet if it is out of range
                elif petName not in petNames:
                    Gumps.SendAction(SUMMON_FAMILIAR_GUMP_ID, petButtonMap[petName])
                    Misc.Pause(250)    
                    
                # Dont do anything, we have this pet and it is in range
                else:
                    goodPetCount = goodPetCount + 1
                    
                # We have all 4 pets and they are nearby. Dont call again
                # for this many seconds                    
                if goodPetCount == 4:
                    Timer.Create("checkSummonFamiliarTimer", 3000)

            # Special case where we got an error that says our connection is too tenous.
            # So, unsummon all existing pets. The thing above that unsummons just does it on
            # a per pet basis if they are out of range.
            if connectionTooTenuous:
                for petName in petButtonMap:
                    if petButtonMap[petName] > 6:
                        if not Gumps.HasGump(SUMMON_FAMILIAR_GUMP_ID):
                            Spells.CastNecro("Summon Familiar")
                            Gumps.WaitForGump(SUMMON_FAMILIAR_GUMP_ID, 1000)                        
                        Gumps.SendAction(SUMMON_FAMILIAR_GUMP_ID, petButtonMap[petName])
                        Misc.Pause(250)    
                        
    return False

# find_first_in_container_by_ids (from core_player.py)
def find_first_in_container_by_ids(itemIDs, containerSerial = Player.Backpack.Serial):
    for itemID in itemIDs:
        item = find_in_container_by_id(itemID, containerSerial)
        if item != None:
            return item
    return None

# get_enemies (from core_mobiles.py)
def get_enemies(range = 10, serialsToExclude = []):
    fil = Mobiles.Filter()
    fil.Enabled = True
    fil.RangeMax = range
    fil.Notorieties = List[Byte](bytes([3,4,5,6]))
    fil.IsGhost = False
    fil.Friend = False
    fil.CheckLineOfSight = True
    mobs = Mobiles.ApplyFilter(fil)
    
    # need to remove Animate dead summons. There are a handfull of MobileIDs that match
    # the regular mobs, however these are red from animate dead when they are normally gray.
    if len(mobs) > 0:
        #for mob in mobs:
            #print(mob.Name, mob.Name not in ANIMATE_DEAD_MOBILE_NAMES and mob.Notoriety != 6 and mob.Serial not in serialsToExclude)
            #print("is in animate dead", mob.Name not in ANIMATE_DEAD_MOBILE_NAMES)
            
        mobsList = List[type(mobs[0])]([mob for mob in mobs if not (mob.Name in ANIMATE_DEAD_MOBILE_NAMES and mob.Notoriety == 6) and mob.Serial not in serialsToExclude])
#        if len(mobsList) == 0:
#            print("No mobs found")
        return mobsList

    return mobs

# is_player_moving (from core_rails.py)
def is_player_moving():
    return user32.GetAsyncKeyState(0x02) & 0x8000

# use_bag_of_sending (from core_player.py)
def use_bag_of_sending(
    # Threshold for a single gold stack before sending
    minGold = 50000):

    bag = find_first_in_container_by_name("a bag of sending", containerSerial = Player.Backpack.Serial)
    if bag is not None:
        goldPiles = find_all_in_container_by_ids(GOLD_STATIC_IDS)
        for goldPile in goldPiles:
            if goldPile.Amount >= minGold:
                Items.UseItem(bag)
                Target.WaitForTarget(1000, False)
                Target.TargetExecute(goldPile)
    else:
        print("No bag of sending found!")

# cast_spell (from core_spells.py)
def cast_spell(
    # Spell from Magery, Spellweaving, Necromancy, Chivalry
    spellName, 
    
    # Optional mobile target, otherwise spell specific logic.
    # This can be a serial, a mobile, or a Point3D (Position)
    target = None,
    
    # Milliseonds of extra delay when computing cast time to account for internet fuzz. Fine tune this as needed.
    latencyMs = 200
):
    Target.Cancel()
    
    if spellName == "Wildfire":
        Spells.CastSpellweaving(spellName)
        Target.WaitForTarget(get_fc_delay(WILDFIRE_DELAY, FC_CAP_SPELLWEAVING, latencyMs))
    elif spellName == "Attune Weapon":
        Spells.CastSpellweaving(spellName)
        Target.WaitForTarget(get_fc_delay(ATTUNE_WEAPON_DELAY, FC_CAP_SPELLWEAVING, latencyMs))
    elif spellName == "Thunderstorm":
        Spells.CastSpellweaving(spellName)
        Misc.Pause(get_fc_delay(THUNDERSTORM_DELAY, FC_CAP_SPELLWEAVING, latencyMs)) 
    elif spellName == "Word of Death":
        Spells.CastSpellweaving(spellName)
        Target.WaitForTarget(get_fc_delay(WORD_OF_DEATH_DELAY, FC_CAP_SPELLWEAVING, latencyMs))
    elif spellName == "Arcane Empowerment":
        Spells.CastSpellweaving(spellName)    
        Target.WaitForTarget(get_fc_delay(ARCANE_EMPOWERMENT_DELAY, FC_CAP_SPELLWEAVING, latencyMs))
        
    elif spellName == "Gift of Life":
        Spells.CastSpellweaving(spellName)    
        Target.WaitForTarget(get_fc_delay(GIFT_OF_LIFE_DELAY, FC_CAP_SPELLWEAVING, latencyMs))
    elif spellName == "Gift of Renewal":
        Spells.CastSpellweaving(spellName)    
        Target.WaitForTarget(get_fc_delay(GIFT_OF_RENEWAL_DELAY, FC_CAP_SPELLWEAVING, latencyMs))

    elif spellName == "Wither":
        Spells.CastNecro(spellName)
        Misc.Pause(get_fc_delay(WITHER_DELAY, FC_CAP_NECROMANCY, latencyMs)) 
    elif spellName == "Conduit":
        Spells.CastMastery(spellName)
        Target.WaitForTarget(get_fc_delay(CONDUIT_DELAY, FC_CAP_NECROMANCY, latencyMs))
    elif spellName == "Corpse Skin":
        Spells.CastNecro(spellName)
        Target.WaitForTarget(get_fc_delay(CORPSE_SKIN_DELAY, FC_CAP_NECROMANCY, latencyMs))
    elif spellName == "Pain Spike":
        Spells.CastNecro(spellName)
        Target.WaitForTarget(get_fc_delay(PAIN_SPIKE_DELAY, FC_CAP_NECROMANCY, latencyMs))        
    elif spellName == "Evil Omen":
        Spells.CastNecro(spellName)
        Target.WaitForTarget(get_fc_delay(EVIL_OMEN_DELAY, FC_CAP_NECROMANCY, latencyMs))
    elif spellName == "Blood Oath":
        Spells.CastNecro(spellName)
        Target.WaitForTarget(get_fc_delay(BLOOD_OATH_DELAY, FC_CAP_NECROMANCY, latencyMs))
    elif spellName == "Strangle":
        Spells.CastNecro(spellName)
        Target.WaitForTarget(get_fc_delay(STRANGLE_DELAY, FC_CAP_NECROMANCY, latencyMs))
    elif spellName == "Poison Strike":
        Spells.CastNecro(spellName)
        Target.WaitForTarget(get_fc_delay(POISON_STRIKE_DELAY, FC_CAP_NECROMANCY, latencyMs))
    elif spellName == "Curse Weapon":
        Spells.CastNecro(spellName)
        Misc.Pause(get_fc_delay(CURSE_WEAPON_DELAY, FC_CAP_NECROMANCY, latencyMs))        
    elif spellName == "Animate Dead":
        Spells.CastNecro(spellName)
        Misc.Pause(get_fc_delay(ANIMATE_DEAD_DELAY, FC_CAP_NECROMANCY, latencyMs))        
    elif spellName == "Wraith Form":
        Spells.CastNecro(spellName)
        Misc.Pause(get_fc_delay(WRAITH_FORM_DELAY, FC_CAP_NECROMANCY, latencyMs))  
    elif spellName == "Vampiric Embrace":
        Spells.CastNecro(spellName)
        Misc.Pause(get_fc_delay(VAMPIRIC_EMBRACE_DELAY, FC_CAP_NECROMANCY, latencyMs))       
    elif spellName == "Poison Field":
        Spells.CastMagery(spellName)
        Target.WaitForTarget(get_fc_delay(POISON_FIELD_DELAY, FC_CAP_MAGERY, latencyMs))
    elif spellName == "Fire Field":
        Spells.CastMagery(spellName)
        Target.WaitForTarget(get_fc_delay(FIRE_FIELD_DELAY, FC_CAP_MAGERY, latencyMs))
    elif spellName == "Poison":
        Spells.CastMagery(spellName)
        Target.WaitForTarget(get_fc_delay(POISON_DELAY, FC_CAP_MAGERY, latencyMs))
        
    elif spellName == "Protection":
        Spells.CastMagery(spellName)
        Misc.Pause(get_fc_delay(PROTECTION_DELAY, FC_CAP_MAGERY, latencyMs))
        
    elif spellName == "Energy Bolt":
        Spells.CastMagery(spellName)
        Target.WaitForTarget(get_fc_delay(ENERGY_BOLT_DELAY, FC_CAP_MAGERY, latencyMs))
    elif spellName == "Flame Strike":
        Spells.CastMagery(spellName)
        Target.WaitForTarget(get_fc_delay(FLAME_STRIKE_DELAY, FC_CAP_MAGERY, latencyMs))
    elif spellName == "Chain Lightning":
        Spells.CastMagery(spellName)
        Target.WaitForTarget(get_fc_delay(CHAIN_LIGHTNING_DELAY, FC_CAP_MAGERY, latencyMs))

    elif spellName == "Death Ray":
        Spells.CastMastery(spellName)
        Target.WaitForTarget(get_fc_delay(DEATH_RAY_DELAY, FC_CAP_MAGERY, latencyMs))
    elif spellName == "Curse":
        Spells.CastMagery(spellName)
        Target.WaitForTarget(get_fc_delay(CURSE_DELAY, FC_CAP_MAGERY, latencyMs))
        Target.TargetExecute(target)
    elif spellName == "Arch Cure":
        Spells.CastMagery(spellName)
        Target.WaitForTarget(get_fc_delay(ARCH_CURE_DELAY, FC_CAP_MAGERY, latencyMs))
    elif spellName == "Greater Heal":
        Spells.CastMagery(spellName)
        Target.WaitForTarget(get_fc_delay(GREATER_HEAL_DELAY, FC_CAP_MAGERY, latencyMs))
    elif spellName == "Remove Curse":
        Spells.CastChivalry(spellName)
        Target.WaitForTarget(get_fc_delay(REMOVE_CURSE_DELAY, FC_CAP_CHIVALRY, latencyMs))
    elif spellName == "Close Wounds":
        Spells.CastChivalry(spellName)
        Target.WaitForTarget(get_fc_delay(CLOSE_WOUNDS_DELAY, FC_CAP_CHIVALRY, latencyMs))        
    elif spellName == "Divine Fury":
        Spells.CastChivalry(spellName)
        Misc.Pause(get_fc_delay(DIVINE_FURY_DELAY, FC_CAP_CHIVALRY, latencyMs))            
    elif spellName == "Consecrate Weapon":
        Spells.CastChivalry(spellName)
        Misc.Pause(get_fc_delay(CONSECRATE_WEAPON_DELAY, FC_CAP_CHIVALRY, latencyMs))            
    elif spellName == "Enemy of One":
        Spells.CastChivalry(spellName)
        Misc.Pause(get_fc_delay(ENEMY_OF_ONE_DELAY, FC_CAP_CHIVALRY, latencyMs))            
    #elif spellName == "Meditation":
    #    Player.UseSkill(spellName)
    elif spellName == "Shield Bash":
        Spells.CastMastery(spellName)
        Misc.Pause(get_fc_delay(SHIELD_BASH_DELAY, FC_CAP_SHIELD_BASH, latencyMs))            
    elif spellName == "Inspire" or spellName == "Invigorate" or spellName == "Resilience" or spellName == "Perseverance":
        Journal.Clear()
        Spells.CastMastery(spellName)
        Misc.Pause(get_fc_delay(BARD_SONG_DELAY, FC_CAP_BARD_SONG, latencyMs))  
        if Journal.Search( 'What instrument shall you play?' ):
            instrument = find_first_in_container_by_ids(INSTRUMENT_STATIC_IDS)
            if instrument is not None:
                Target.TargetExecute(instrument)
                Target.WaitForTarget(latencyMs)
            else:
                Misc.SendMessage("No instruments found to play bard songs!")        
    else:
        Player.HeadMessage(28, "That spell is not supported! Pausing.")
        Misc.Pause(1000)

    if target is not None:
        if type(target).__name__ == "Point3D":
            Target.TargetExecute(target.X, target.Y, target.Z)
        else:
            Target.TargetExecute(target)
    
    Misc.Pause(get_fcr_delay(spellName, latencyMs))

# get_honor_target (from core_mobiles.py)
def get_honor_target():
    for mob in get_enemies(10):
        if mob.Hits == mob.HitsMax:
            return mob

# use_skill (from core_spells.py)
def use_skill(

    # Meditation, Spirit Speak, etc.
    skillName,
    
    # (Optional) Mobile
    target = None,
    
    # (Optional) 
    latencyMs = None
):
    
    if skillName == "Discordance": 
        Journal.Clear()
        
    Player.UseSkill(skillName)
    
    if skillName == "Meditation":
        Misc.Pause(MEDITATION_DELAY)
    elif skillName == "Spirit Speak":
        Misc.Pause(SPIRIT_SPEAK_DELAY)
    elif skillName == "Discordance":
        Target.WaitForTarget(latencyMs)
        if Journal.Search( 'What instrument shall you play?' ) or Journal.Search( 'No instruments found to Discord with!' ):
        #if Journal.Search( 'No instruments found to Discord with!' ):
            instrument = find_first_in_container_by_ids(INSTRUMENT_STATIC_IDS)
            if instrument is not None:
                Target.TargetExecute(instrument)
                Target.WaitForTarget(latencyMs)
            else:
                Misc.SendMessage("No instruments found to Discord with!")
        Target.TargetExecute(target)
        Misc.Pause(latencyMs)
        
    else:
        Misc.Pause(1000)

# heal_player_and_friends (from core_attack.py)
def heal_player_and_friends(

    # 0 = Heal only names in friendNames, 1 = heal any blue in range, 2 = my pets only
    friendSelectMethod = 0,
    
    # Pets, friends, etc. These are names (string).
    friendNames = [],
    
    # If friends and pets are farther than this, dont bother with this.
    range = 8,

    # Only heal when pet/player life is below this threshold
    healThreshold = 0.7, 
    
    # Whether to cure yourself or your pet
    useCure = 0,
    
    # Whether to heal yourself or your pet (heals are mutually exclusive, only one will work, so just pick one)
    useGreaterHeal = 0,
    
    # Paladin spell for healing, only works on self. (heals are mutually exclusive, only one will work, so just pick one)
    useCloseWounds = 0,
    
    # Paladin spell for curing poisons, only works on self.
    useCleanseByFire = 0,
    
    # Chivalry spell
    useRemoveCurse = 0,
    
    # Necro heal (heals are mutually exclusive, only one will work, so just pick one)
    useSpiritSpeak = 0,
    
    # InsaneUO specific. There is a cloak that grants immunity. Looks like 30 second cooldown.
    # Looks for item on Cloak layer and uses it. Timer for this is created in the main core_attack script.
    useCloakOfGraveMists = 0,
    
    # Spellweaving spell. Think its 2.5 min cooldown.
    # 0 = Do not use
    # 1 = Cast on yourself or anyone in friends list (uses timer to track cooldown so not very reliable on restart)
    useGiftOfRenewal = 0,
    
    # Bandage self. Requires healing skill and bandages in top level of pack.
    # 0 = Disabled, 1 = Enabled
    useBandagesOnSelf = 0,
    
    # Milliseonds of extra delay when computing cast time to account for internet fuzz. Fine tune this as needed.
    latencyMs = 100
):
    
    if useCure == 0 and useGreaterHeal == 0 and useCloseWounds == 0 and useCleanseByFire == 0 and useRemoveCurse == 0 and useSpiritSpeak == 0 and useCloakOfGraveMists == 0 and useGiftOfRenewal == 0 and useBandagesOnSelf == 0:
        return False
        
    bandage = find_in_container_by_id(BANDAGE_STATIC_ID) if useBandagesOnSelf == 1 else None
    
    if useCloakOfGraveMists == 1 and Timer.Check("cloakOfGraveMistsTimer") == False and Player.Hits / Player.HitsMax <= 0.25:
        cloak = Player.GetItemOnLayer("Cloak")    
        Items.UseItem(cloak)
        Target.WaitForTarget(1000)
        Target.Cancel()
        Timer.Create( 'cloakOfGraveMistsTimer', 30000 )
        Misc.Pause(100)
        return True
    elif useBandagesOnSelf == 1 and bandage is not None and not Player.BuffsExist("Healing") and (Player.Hits / Player.HitsMax < healThreshold or Player.Poisoned):
        Items.UseItem(bandage)
        Target.WaitForTarget(1500)
        Target.TargetExecute(Player.Serial)
    elif useGiftOfRenewal == 1 and Timer.Check("useGiftOfRenewalTimer") == False and Player.Hits / Player.HitsMax < healThreshold:
        cast_spell("Gift of Renewal", Player.Serial, latencyMs)
        Timer.Create("useGiftOfRenewalTimer", 60 * 2500)
        return True
    elif useCure == 1 and Player.Poisoned:
        cast_spell("Arch Cure", Player.Serial)
        return True
    elif useGreaterHeal == 1 and not Player.Poisoned and Player.Hits / Player.HitsMax < healThreshold and not Player.YellowHits and Player.Mana > 15:
        cast_spell("Greater Heal", Player.Serial, latencyMs)
        return True
    elif useCloseWounds == 1 and not Player.Poisoned and Player.Hits / Player.HitsMax < healThreshold and not Player.YellowHits and Player.Mana > 15:
        cast_spell("Close Wounds", Player.Serial, latencyMs)
        return True
    elif useSpiritSpeak == 1 and not Player.Poisoned and Player.Hits / Player.HitsMax < healThreshold and not Player.YellowHits and Player.Mana > 15:
        use_skill("Spirit Speak")
        return True
    elif useCleanseByFire == 1 and Player.Poisoned and Player.Mana > 15:
        cast_spell("Cleanse by Fire", None, latencyMs)
        return False # Doing this on purpose, this isnt superimportant for melee.
        
    # Not super important, attempt to remove every x seconds instead of every tick becauase it is wasteful. You need to use mana to attack.
    elif useRemoveCurse == 1 and (Player.BuffsExist("Curse") or Player.BuffsExist("Feeblemind") or Player.BuffsExist("Corpse Skin") or Player.BuffsExist("Clumsy") or Player.BuffsExist("Mind Rot") or Player.BuffsExist("Weaken")) and Player.Mana > 15 and Timer.Check("useRemoveCurseNonCriticalTimer") == False:
        cast_spell("Remove Curse", Player.Serial, latencyMs)
        Timer.Create("useRemoveCurseNonCriticalTimer", 10000)
        return False # Doing this on purpose, this isnt super important for melee.
    # Critical curses, always attempt to remove
    elif useRemoveCurse == 1 and (Player.BuffsExist("Blood Oath (curse)")) and Player.Mana > 15:
        cast_spell("Remove Curse", Player.Serial, latencyMs)
        return False # Doing this on purpose, this isnt super important for melee.
        
    # Now lets heal our friends
    if friendSelectMethod == 0: 
        friendMobiles = get_friends_by_names(friendNames, range)
    elif friendSelectMethod == 1:
        friendMobiles = get_blues_in_range(range)
    elif friendSelectMethod == 2:
        friendMobiles = get_pets()
        
    def sort_friends(x, y):
        if x is None or y is None:
            return False
        if x.HitsMax is None or x.HitsMax == 0 or y.HitsMax is None or y.HitsMax == 0:
            return False
        return x.Hits / x.HitsMax > y.Hits / y.HitsMax 
        
    if len(friendMobiles) > 0:
        friendMobiles.Sort(sort_friends)
        friendMobile = friendMobiles[0]
        
        if not (useCure == 1 and friendMobile.Poisoned) and not ((useGreaterHeal == 1 or useGiftOfRenewal == 1) and not friendMobile.Poisoned and friendMobile.HitsMax is not None and friendMobile.HitsMax > 0 and friendMobile.Hits / friendMobile.HitsMax < healThreshold and not friendMobile.YellowHits and friendMobile.Hits > 0) and Player.Mana < 15:
            return False
        
        if useCure == 1 and friendMobile.Poisoned:
            cast_spell("Arch Cure", friendMobile, latencyMs)
            return True
        elif useGiftOfRenewal == 1 and Timer.Check("useGiftOfRenewalTimer") == False and not friendMobile.Poisoned and friendMobile.HitsMax is not None and friendMobile.HitsMax > 0 and friendMobile.Hits / friendMobile.HitsMax < healThreshold and not friendMobile.YellowHits and friendMobile.Hits > 0:
            cast_spell("Gift of Renewal", friendMobile, latencyMs)
            Timer.Create("useGiftOfRenewalTimer", 60 * 2500)
            return True
        elif useGreaterHeal == 1 and not friendMobile.Poisoned and friendMobile.HitsMax is not None and friendMobile.HitsMax > 0 and friendMobile.Hits / friendMobile.HitsMax < healThreshold and not friendMobile.YellowHits and friendMobile.Hits > 0:
            cast_spell("Greater Heal", friendMobile, latencyMs)
            return True

    return False

# run_mage_loop (from core_attack.py)
def run_mage_loop(

    # Give it a fun name in case you have different versions, e.g.
    # Mage AOE Loop or Mage Single Target Loop
    loopName = "Mage Loop",

    # Applicable when heal spells are enabled (Greater Heal, etc.) which are configured
    # down below. This governs how you want to heal allies. By default your character is always healed.
    # 0 = Heal only names in friendNames array (below), 1 = heal any blue in range, 2 = my pets only
    friendSelectMethod = 0,
    
    # Names of pets or blue characters you want to heal / cure if they are in range.
    # Note that you still need to enable useCure / useGreaterHeal etc.
    friendNames = [],
    
    # Only look for mobs and pets/friends inside of this range. IF they are farther, then
    # dont heal them / dont attack them.
    range = 8,
    
    # Use Arcane Empowerment (spell weaving) 0 = disabled, 1 = enabled
    # Will cast every time buff expires automatically AND an enemy is in range.
    useArcaneEmpowerment = 0,
    
    # Main spammable nuke. Cast when only 1 - 2 mobs.
    # 0 = Disabled, no nuke.
    # 1 = Poison Strike (Necro)
    # 2 = Energy Bolt (Magery)
    # 3 = Flame Strike (Magery)
    mainNukeSpell = 0,
    
    # Delay between nuke casts. Timer starts when casting is finished.
    # By default there is only 100ms delay between casts.
    mainNukeDelayMs = 100,
    
    # Main spammable AoE. Note that wildfire has its own configuration since its a DoT type.
    # Cast when > 2 mobs.
    # 0 = Disabled, dont cast any aoe spells.
    # 1 = Wither (Necro)
    # 2 = Thunderstorm (Magery)
    # 3 = Chain Lightning (Magery)
    mainAoeSpell = 0,
    
    # Delay between AoE attacks. Timer starts when casting is finished.
    # By default there is hardly any delay, 100ms.
    mainAoeDelayMs = 100,
    
    # Threshold count of mobs within aoeRange. If found, will cast mainAoeSpell.
    aoeMinMobCount = 3,
    
    # Counts monsters within this range of tiles from player (inclusive).
    aoeMaxRange = 7,
    
    # Whether to use this spell 0 = disabled, 1 = enabled
    useStrangle = 0,
    
    # Change to an appropriate value for strangle spell, number of MS in between usages
    strangleDelayMs = 60000,
    
    # Whether to use this spell 0 = disabled, 1 = enabled
    useCorpseSkin = 0,
    
    # Change to an appropriate value, number of MS in between usages
    corpseSkinDelayMs = 60000,
    
    # Couple of different modes:
    # 0 = Disabled
    # 1 = Use before dots and curses (e.g. strangle and corpse skin)
    # 2 = Use based on the delay variable below
    useEvilOmen = 0,
    
    # Adding this option because it is wild on InsaneUO. It is a pretty cool dot.
    evilOmenDelayMs = 20000,
    
    # Cast blood oath necro spell
    useBloodOath = 0,
    
    # Time between blood oath casts in milliseconds
    bloodOathDelayMs = 30000,
    
    # Whether to use the magery curse spell, 0 = disabled, 1 = enabled
    useCurse = 0,
    
    # How often to cast this spell in millesconds
    curseDelayMs = 60000,
    
    # Whether to use the magery spell poison, will only cast if poison is not on target 0 = disabled, 1 = enabled
    usePoison = 0,
    
    # How often we can cast poison in milliseconds
    poisonDelayMs = 30000,
    
    # Magery poison field spell 0 = disabled, 1 = enabled. Will only cast if there is a nonpoisoned mob.
    usePoisonField = 0,
    
    # How often to cast this spell in milliseconds
    poisonFieldDelayMs = 10000,
    
    # Magery fire field spell 0 = disabled, 1 = enabled.
    useFireField = 0,
    
    # How often to cast this spell in milliseconds
    fireFieldDelayMs = 10000,
    
    # Toggles death ray. Requires magery mastery. There is no timer because this remains
    # active until you move or you are interrupted or the creature dies. It will attempt to
    # reapply immediately. 0 = disabled, 1 = enabled
    useDeathRay = 0,
    
    # Will use shadow word death on eligible targets until they die. This is more of a toggle.
    # 0 = disabled, 1 = enabled
    useWordOfDeath = 0,
    
    # Whether to use this spell 0 = disabled, 1 = enabled
    useWildfire = 0,
    
    # Lower number like 10 means to spam repeatadly, number of MS in between usages
    wildfireDelayMs = 9000,
    
    # Use necromancy pain spike every 10 seconds. On some servers this might be good.
    usePainSpike = 0,
    
    # This is Insane UO Specific. That means there is no target reticle. Wont work
    # on other servers.
    useAnimateDead = 0,
    
    # Cast it this often
    animateDeadDelayMs = 60000,
    
    # InsaneUO specific. Keeps all 4 pets summoned when safe to cast.
    useSummonFamiliar = 0,
    
    # Make sure we are in wraith form when it is safe to cast.
    # 0 = Do not force any form.
    # 1 = Make sure we are in wraith form.
    # 2 = Make sure we are in vampire form.
    useForm = 0,
    
    # Whether to cure yourself or your pet
    useCure = 0,
    
    # Whether to heal yourself or your pet
    useGreaterHeal = 0,
    
    # Necro heal
    useSpiritSpeak = 0,
    
    # Necro mastery for aoe damage, looks for buff. If no buff, casts it.
    # 0 = Do not use
    # 1 = Cast only when buff is not present in buff bar (kind of unreliable)
    # 2 = Cast every conduitDelayMs milliseconds
    useConduit = 0,
    
    # Recast conduit after this many milliseconds. Only applicablewhen useConduit = 2.
    conduitDelayMs = 15000,
    
    # When standing still, no mobes in range, not bleeding, strangled, or poisoned, will start meditating.
    useMeditation = 0,
    
    # Only heal things that are below this percent HP
    healThreshold = 0.70,
    
    # InsaneUO specific. There is a cloak that grants immunity. Looks like 30 second cooldown.
    # Looks for item on Cloak layer and uses it. Timer for this is created in the main core_attack script.
    useCloakOfGraveMists = 0,
    
    # Spellweaving spell. Think its 2.5 min cooldown.
    # 0 = Do not use
    # 1 = Cast on yourself or anyone in friends list (uses timer to track cooldown so not very reliable on restart)
    useGiftOfRenewal = 0,
    
    # 0 = Do not use
    # 1 = Cast on yourself and pet (uses your buff to track, not pets, so not very reliable)
    useGiftOfLife = 0,
    
    # Attune weapon has a cooldown. Stratics says 2 minues. On IUO it is longer. It might have
    # something to do with Focus skill. I dont know. So, Im setting this to about 4 minutes.
    # 0 = Do not use
    # 1 = Cast on self.
    useAttuneWeapon = 0,
    
    # Use a bard ability.
    # 0 = Default, do nothing
    # 1 = Peacemaking (notimplemented)
    # 2 = Provocation (notimplemented)
    # 3 = Discord (Yes)
    useBardAbility = 0,
    
    # Wait this long in milliseconds between bard ability uses
    bardAbilityDelayMs = 10000,
    
    # List the bard songs you wish to use. 
    # 0 = Default, do nothing
    # 1 = Peacemaking (Resilience, Perseverance)
    # 2 = Provocation (Inspire, Invigorate)
    # 3 = Discord (does nothing)
    useBardSongs = 0,
    
    # Use the Magery Protection spell. Casts when no nearby enemies.
    useProtection = 0,
    
    # EXPERIMENTAL: Does not work great. Would recommend not using this.
    # Whether to honor a nearby enemy to gain the perfection buff.
    # Will try to find an enemy at full health when the buff doesnt exist on player.
    useHonor = 0,
    
    # If greater than 0 will attempt to use bag of sending when this much gold is present. Default is 0, no bag of sending usage.
    minGold = 0,
    
    # Milliseonds of extra delay when computing cast time to account for internet fuzz. Fine tune this as needed.
    latencyMs = 200
):
    Timer.Create( 'animateDeadTimer', animateDeadDelayMs )

    if Player.Visible:
        Player.ChatSay("All Guard Me")
        Misc.Pause(250)
    
    while not Player.IsGhost:
        #Target.Cancel()
        
        if Timer.Check( 'magePingTimer' ) == False:
            Player.HeadMessage( 78, "{} Running...".format(loopName) )
            Timer.Create( 'magePingTimer', 10000 )

        if not Player.Visible:
            Misc.Pause(500)
            continue  
            
        if minGold > 0 and Player.Gold >= minGold:
            use_bag_of_sending(minGold)            
            
        if is_player_moving():
            Misc.Pause(250)
            continue

        # Continue loop before doing harmul actions, focus on healing/curing.
        if heal_player_and_friends(friendSelectMethod = friendSelectMethod, friendNames = friendNames, range = range, healThreshold = healThreshold, useCure = useCure, useGreaterHeal = useGreaterHeal, useSpiritSpeak = useSpiritSpeak, useCloakOfGraveMists = useCloakOfGraveMists, useGiftOfRenewal = useGiftOfRenewal) == True:
            if useArcaneEmpowerment == 1 and not Player.BuffsExist("Arcane Empowerment") and Player.Mana > 90 and Player.Hits > 50:
                cast_spell("Arcane Empowerment", None, latencyMs)
            continue
            
        if Player.BuffsExist("Meditation") and Player.Mana / Player.ManaMax < 0.65:
            Misc.Pause(250)
            continue
            
        # Buffs / Forms
        if Player.Mana > 30 and Player.Hits / Player.HitsMax > 0.90:
            if useForm == 1 and Player.Mana > 30 and not Player.BuffsExist("Wraith Form") and Timer.Remaining("cloakOfGraveMistsTimer") < 20000:
                cast_spell("Wraith Form", None, latencyMs)
                continue
            elif useForm == 2 and Player.Mana > 30 and not Player.BuffsExist("Vampiric Embrace") and Timer.Remaining("cloakOfGraveMistsTimer") < 20000:
                cast_spell("Vampiric Embrace", None, latencyMs)
                continue
            elif useBardSongs == 2 and Player.Mana > 50 and not Player.BuffsExist("Invigorate"):
                cast_spell("Invigorate", None, latencyMs)
                continue
            elif useBardSongs == 2 and Player.Mana > 50 and not Player.BuffsExist("Inspire"):
                cast_spell("Inspire", None, latencyMs)
                continue
            elif useBardSongs == 1 and Player.Mana > 50 and not Player.BuffsExist("Resilience"):
                cast_spell("Resilience", None, latencyMs)
                continue
            elif useBardSongs == 1 and Player.Mana > 50 and not Player.BuffsExist("Perseverance"):
                cast_spell("Perseverance", None, latencyMs) 
                continue
            elif useProtection == 1 and Player.Mana > 25 and not Player.BuffsExist("Protection"):
                cast_spell("Protection", None, latencyMs)
                continue
            elif useGiftOfLife == 1 and Player.Mana > 125 and not Player.BuffsExist("Gift of Life"):
                # This is a not so great way of doing this. When player loses debuff, we
                # re-apply to Pet and Player. Pet may not need it. And there may be times
                # when we dont need  it but pet does.
                pets = get_pets()
                if len(pets) > 0:
                    # Just cast on first pet, this spell is expensive.
                    cast_spell("Gift of Life", pets[0], latencyMs)
                # Cast on self
                cast_spell("Gift of Life", Player.Serial, latencyMs)
                continue
            elif useAttuneWeapon == 1 and Player.Mana > 50 and not Player.BuffsExist("Attune Weapon") and Timer.Check("attuneWeaponTimer") == False:
                cast_spell("Attune Weapon", None, latencyMs)
                Timer.Create("attuneWeaponTimer", 4 * 60 * 1000)
                continue
                
            if useSummonFamiliar == 1 and Player.Mana > 40:
                if check_summon_familiar(latencyMs):
                    #Misc.Pause(250)
                    continue

        eligible = get_enemies(range)
        if len(eligible) > 0:  
            nearestMob = Mobiles.Select(eligible, 'Nearest')
            nonPoisonedMob = next((mob for mob in eligible if not mob.Poisoned and get_mobile_percent_hp(mob) > 0.5), None)
            countMobsInAoeRange = sum(1 for mob in eligible if Player.DistanceTo(mob) < aoeMaxRange)
            
            # Experimental
            honorMob = get_honor_target() if useHonor == 1 and not Player.BuffsExist("Perfection") else None
            if honorMob is not None:
                Player.InvokeVirtue("Honor")
                Target.WaitForTarget(1000, False)
                Target.TargetExecute(honorMob)
            elif useBardAbility == 3 and Timer.Check("discordTimer") == False:
                use_skill("Discordance", nearestMob, latencyMs)
                Timer.Create("discordTimer", bardAbilityDelayMs)
            elif useArcaneEmpowerment == 1 and not Player.BuffsExist("Arcane Empowerment") and Player.Mana > 90 and Player.Hits > 50:
                cast_spell("Arcane Empowerment", None, latencyMs)            
            elif useConduit == 1 and not Player.BuffsExist("Conduit") and len(eligible) > 2 and Player.DistanceTo(nearestMob) > 0:
                cast_spell("Conduit", nearestMob.Position, latencyMs)
            elif useConduit == 2 and  Timer.Check( 'conduitTimer' ) == False and len(eligible) > 2 and Player.DistanceTo(nearestMob) > 0:
                cast_spell("Conduit", nearestMob, latencyMs)
                Timer.Create( 'conduitTimer', conduitDelayMs ) 
            elif useWordOfDeath == 1 and get_mobile_percent_hp(nearestMob) < 0.3 and len(eligible) <= 3:
                cast_spell("Word of Death", nearestMob, latencyMs)   
            elif useDeathRay == 1 and not Player.BuffsExist("Death Ray") and Player.BuffsExist("Arcane Empowerment") and (not Player.BuffsExist("Poison") and not Player.BuffsExist("Strangle")) and Player.Mana > 125:
                cast_spell("Death Ray", nearestMob, latencyMs)                                
                         
            elif usePainSpike == 1  and Timer.Check( 'painSpikeTimer' ) == False and not Player.BuffsExist("Conduit"):
                cast_spell("Pain Spike", nearestMob, latencyMs)
                Timer.Create( 'painSpikeTimer', 10500 )
            elif useEvilOmen == 2 and Timer.Check( 'evilOmenTimer' ) == False:
                cast_spell("Evil Omen", nearestMob, latencyMs)
                Timer.Create( 'evilOmenTimer', evilOmenDelayMs )
            elif useCorpseSkin == 1 and Timer.Check( 'corpseSkinTimer' ) == False and get_mobile_percent_hp(nearestMob) > 0.5:
                if useEvilOmen == 1:
                    cast_spell("Evil Omen", nearestMob, latencyMs)
                cast_spell("Corpse Skin", nearestMob, latencyMs)
                Timer.Create( 'corpseSkinTimer', corpseSkinDelayMs )
            elif useStrangle == 1 and Timer.Check( 'strangleTimer' ) == False and get_mobile_percent_hp(nearestMob) > 0.5:
                if useEvilOmen == 1:
                    cast_spell("Evil Omen", nearestMob, latencyMs)
                cast_spell("Strangle", nearestMob, latencyMs)
                Timer.Create( 'strangleTimer', strangleDelayMs ) 
            elif usePoison == 1 and Timer.Check( 'poisonTimer' ) == False and nonPoisonedMob is not None:
                if useEvilOmen == 1:
                    cast_spell("Evil Omen", nonPoisonedMob, latencyMs)
                cast_spell("Poison", nonPoisonedMob, latencyMs)
                Timer.Create( 'poisonTimer', poisonDelayMs) 
            elif useBloodOath == 1 and Timer.Check( 'bloodOathTimer' ) == False:
                cast_spell("Blood Oath", nearestMob, latencyMs)
                Timer.Create( 'bloodOathTimer', bloodOathDelayMs )
            elif useCurse == 1 and Timer.Check( 'curseTimer' ) == False and get_mobile_percent_hp(nearestMob) > 0.75:
                if useEvilOmen == 1:
                    cast_spell("Evil Omen", nearestMob, latencyMs)
                cast_spell("Curse", nearestMob, latencyMs)
                Timer.Create( 'curseTimer', curseDelayMs) 
            elif useAnimateDead == 1 and Timer.Check( 'animateDeadTimer' ) == False and Player.Hits / Player.HitsMax > 0.90:
                cast_spell("Animate Dead", None, latencyMs)
                Timer.Create( 'animateDeadTimer', animateDeadDelayMs)
            elif useWildfire == 1 and Timer.Check( 'wildfireTimer' ) == False:
                #cast_spell("Wildfire", nearestMob, latencyMs)
                cast_spell("Wildfire", nearestMob.Position, latencyMs)
                Timer.Create( 'wildfireTimer', wildfireDelayMs )
            elif usePoisonField == 1 and Timer.Check( 'poisonFieldTimer' ) == False and nonPoisonedMob is not None:
                cast_spell("Poison Field", nonPoisonedMob, latencyMs)
                Timer.Create( 'poisonFieldTimer', poisonFieldDelayMs)                 
            elif useFireField == 1 and Timer.Check( 'fireFieldTimer' ) == False:
                cast_spell("Fire Field", nearestMob, latencyMs)
                Timer.Create( 'fireFieldTimer', fireFieldDelayMs)                 
            elif mainNukeSpell == 1  and Timer.Check( 'mainNukeTimer' ) == False and (countMobsInAoeRange < aoeMinMobCount or mainAoeSpell == 0):
                cast_spell("Poison Strike", nearestMob, latencyMs)
                Timer.Create( 'mainNukeTimer', mainNukeDelayMs )
            elif mainNukeSpell == 2  and Timer.Check( 'mainNukeTimer' ) == False and (countMobsInAoeRange < aoeMinMobCount or mainAoeSpell == 0):
                cast_spell("Energy Bolt", nearestMob, latencyMs)
                Timer.Create( 'mainNukeTimer', mainNukeDelayMs ) 
            elif mainNukeSpell == 3  and Timer.Check( 'mainNukeTimer' ) == False and (countMobsInAoeRange < aoeMinMobCount or mainAoeSpell == 0):
                cast_spell("Flame Strike", nearestMob, latencyMs)
                Timer.Create( 'mainNukeTimer', mainNukeDelayMs ) 
            elif mainAoeSpell == 1 and Timer.Check( 'mainAoeTimer' ) == False and countMobsInAoeRange >= aoeMinMobCount and Player.Mana > 30:
                cast_spell("Wither", None, latencyMs)
                Timer.Create( 'mainAoeTimer', mainAoeDelayMs ) 
            elif mainAoeSpell == 2 and Timer.Check( 'mainAoeTimer' ) == False and countMobsInAoeRange >= aoeMinMobCount and Player.Mana > 30:
                cast_spell("Thunderstorm", None, latencyMs)
                Timer.Create( 'mainAoeTimer', mainAoeDelayMs ) 
            elif mainAoeSpell == 3  and Timer.Check( 'mainAoeTimer' ) == False and countMobsInAoeRange >= aoeMinMobCount and Player.Mana > 30:
                cast_spell("Chain Lightning", nearestMob, latencyMs)
                Timer.Create( 'mainAoeTimer', mainAoeDelayMs )
            elif useMeditation == 1 and Player.Mana / Player.ManaMax < 0.35 and not Player.Poisoned and not Player.BuffsExist("Bleeding") and not Player.BuffsExist("Strangle") and Timer.Check( 'meditationTimer' ) == False:
                Player.HeadMessage(58, "Stand still - going to meditate!")
                Misc.Pause(500)
                use_skill("Meditation")
                Player.HeadMessage(58, "Meditating!")
                Timer.Create( 'meditationTimer', 10000)    
            
        elif Player.Hits / Player.HitsMax < 0.95 and Player.Mana > 20 and (useGreaterHeal == 1 or useSpiritSpeak == 1 or useCure == 1) and not Player.BuffsExist("Invigorate") and not Player.BuffsExist("Gift of Renewal"):
            # Top player off if no one is around and its safe (and only if player doesnt have any Heal over time)
            heal_player_and_friends(friendSelectMethod = 0, friendNames = [], range = range, healThreshold = 0.95, useCure = useCure, useGreaterHeal = useGreaterHeal, useSpiritSpeak = useSpiritSpeak, useCloakOfGraveMists = 0)
            
        elif useMeditation == 1 and Player.Mana / Player.ManaMax < 0.83 and not Player.Poisoned and not Player.BuffsExist("Bleeding") and not Player.BuffsExist("Strangle") and Timer.Check( 'meditationTimer' ) == False:
            Player.HeadMessage(58, "Stand still - going to meditate!")
            Misc.Pause(500)
            use_skill("Meditation")
            Player.HeadMessage(58, "Meditating!")
            Timer.Create( 'meditationTimer', 10000) 
                
        Misc.Pause(100)

# ===============================================
# Main Script Code
# ===============================================
#   This one is configured for a Mage SpellWeaver Tamer Bard
#   It doesnt cast any AoE or damage spells, just Discordance.
#   Uses the Provo Bard songs.

#   Can cast Necro, Magery, Spellweaving Spells - and some Bard stuff.
# 
#   Run different configurations:
#   1. Pure Necro 
#   2. Mage Tamer 
#   3. Bard SW Tamer
#   4. Healer Only
#   5. Big SW AoE 
#   6. Big Boom Boom Death Ray Mage
#
#   Read the options below and configure as needed. Highlights are just pick a single target nuke
#   and an AoE. Pick heals you want. Set friends. As an added bonus, this will also work with bag 
#   of sending and automatically bank gold.
run_mage_loop(

    # Give it a fun name in case you have different versions, e.g.
    # Mage AOE Loop or Mage Single Target Loop
    loopName = "Bard Mage Wildfire",

    # Applicable when heal spells are enabled (Greater Heal, etc.) which are configured
    # down below. This governs how you want to heal allies. By default your character is always healed.
    # 0 = Heal only names in friendNames array (below), 1 = heal any blue in range, 2 = my pets only
    friendSelectMethod = 0,
    
    # Names of pets or blue characters you want to heal / cure if they are in range.
    # Note that you still need to enable useCure / useGreaterHeal etc.
    friendNames = ["Goldberry", "Nymera Getsum", "omg arturo", "omg arthur", "badhorsey", "omg art", "omg artus", "omg artie", "goodhorsey"],
    
    # Only look for mobs and pets/friends inside of this range. IF they are farther, then
    # dont heal them / dont attack them.
    range = 10,
    
    # Use Arcane Empowerment (spell weaving) 0 = disabled, 1 = enabled
    # Will cast every time buff expires automatically AND an enemy is in range.
    useArcaneEmpowerment = 1,
    
    # Main spammable nuke. Cast when only 1 - 2 mobs.
    # 0 = Disabled, no nuke.
    # 1 = Poison Strike (Necro)
    # 2 = Energy Bolt (Magery)
    # 3 = Flame Strike (Magery)
    mainNukeSpell = 0,
    
    # Delay between nuke casts. Timer starts when casting is finished.
    # By default there is only 100ms delay between casts.
    mainNukeDelayMs = 100,
    
    # Main spammable AoE. Note that wildfire has its own configuration since its a DoT type.
    # Cast when > 2 mobs.
    # 0 = Disabled, dont cast any aoe spells.
    # 1 = Wither (Necro)
    # 2 = Thunderstorm (Magery)
    # 3 = Chain Lightning (Magery)
    mainAoeSpell = 0,
    
    # Delay between AoE attacks. Timer starts when casting is finished.
    # By default there is hardly any delay, 100ms.
    mainAoeDelayMs = 100,
    
    # Threshold count of mobs within aoeRange. If found, will cast mainAoeSpell.
    aoeMinMobCount = 3,
    
    # Counts monsters within this range of tiles from player (inclusive).
    aoeMaxRange = 8,
    
    # Whether to use this spell 0 = disabled, 1 = enabled
    useStrangle = 0,
    
    # Change to an appropriate value for strangle spell, number of MS in between usages
    strangleDelayMs = 60000,
    
    # Whether to use this spell 0 = disabled, 1 = enabled
    useCorpseSkin = 0,
    
    # Change to an appropriate value, number of MS in between usages
    corpseSkinDelayMs = 60000,
    
    # Couple of different modes:
    # 0 = Disabled
    # 1 = Use before dots and curses (e.g. strangle and corpse skin)
    # 2 = Use based on the delay variable below
    useEvilOmen = 0,
    
    # Adding this option because it is wild on InsaneUO. It is a pretty cool dot.
    evilOmenDelayMs = 20000,
    
    # Cast blood oath necro spell
    useBloodOath = 0,
    
    # Time between blood oath casts in milliseconds
    bloodOathDelayMs = 30000,
    
    # Whether to use the magery curse spell, 0 = disabled, 1 = enabled
    useCurse = 0,
    
    # How often to cast this spell in millesconds
    curseDelayMs = 60000,
    
    # Whether to use the magery spell poison, will only cast if poison is not on target 0 = disabled, 1 = enabled
    usePoison = 0,
    
    # How often we can cast poison in milliseconds
    poisonDelayMs = 30000,
    
    # Magery poison field spell 0 = disabled, 1 = enabled. Will only cast if there is a nonpoisoned mob.
    usePoisonField = 0,
    
    # How often to cast this spell in milliseconds
    poisonFieldDelayMs = 10000,
    
    # Magery fire field spell 0 = disabled, 1 = enabled.
    useFireField = 0,
    
    # How often to cast this spell in milliseconds
    fireFieldDelayMs = 10000,
    
    # Toggles death ray. Requires magery mastery. There is no timer because this remains
    # active until you move or you are interrupted or the creature dies. It will attempt to
    # reapply immediately. 0 = disabled, 1 = enabled
    useDeathRay = 0,
    
    # Will use shadow word death on eligible targets until they die. This is more of a toggle.
    # 0 = disabled, 1 = enabled
    useWordOfDeath = 1,
    
    # Whether to use this spell 0 = disabled, 1 = enabled
    useWildfire = 1,
    
    # Use necromancy pain spike every 10 seconds. On some servers this might be good.
    usePainSpike = 0,
    
    # This is Insane UO Specific. That means there is no target reticle. Wont work
    # on other servers.
    useAnimateDead = 0,
    
    # Cast it this often
    animateDeadDelayMs = 60000,
    
    # InsaneUO specific. Keeps all 4 pets summoned when safe to cast.
    useSummonFamiliar = 0,
    
    # Make sure we are in wraith form when it is safe to cast.
    # 0 = Do not force any form.
    # 1 = Make sure we are in wraith form.
    # 2 = Make sure we are in vampire form.
    useForm = 0,
    
    # Whether to cure yourself or your pet
    useCure = 1,
    
    # Whether to heal yourself or your pet
    useGreaterHeal = 1,
    
    # Necro heal
    useSpiritSpeak = 0,
    
    # Necro mastery for aoe damage, looks for buff. If no buff, casts it.
    # 0 = Do not use
    # 1 = Cast only when buff is not present in buff bar (kind of unreliable)
    # 2 = Cast every conduitDelayMs milliseconds
    useConduit = 0,
    
    # Recast conduit after this many milliseconds. Only applicablewhen useConduit = 2.
    conduitDelayMs = 15000,
    
    # When standing still, no mobes in range, not bleeding, strangled, or poisoned, will start meditating.
    useMeditation = 0,
    
    # Only heal things that are below this percent HP
    healThreshold = 0.70,
    
    # InsaneUO specific. There is a cloak that grants immunity. Looks like 30 second cooldown.
    # Looks for item on Cloak layer and uses it. Timer for this is created in the main core_attack script.
    useCloakOfGraveMists = 0,
    
    # Spellweaving spell. Think its 2.5 min cooldown.
    # 0 = Do not use
    # 1 = Cast on yourself or anyone in friends list (uses timer to track cooldown so not very reliable on restart)
    useGiftOfRenewal = 1,
    
    # 0 = Do not use
    # 1 = Cast on yourself and pet (uses your buff to track, not pets, so not very reliable)
    useGiftOfLife = 1,
    
    # Attune weapon has a cooldown. Stratics says 2 minues. On IUO it is longer. It might have
    # something to do with Focus skill. I dont know. So, Im setting this to about 4 minutes.
    # 0 = Do not use
    # 1 = Cast on self.
    useAttuneWeapon = 1,
    
    # Use a bard ability.
    # 0 = Default, do nothing
    # 1 = Peacemaking (notimplemented)
    # 2 = Provocation (notimplemented)
    # 3 = Discord (Yes)
    useBardAbility = 3,
    
    # Wait this long in milliseconds between bard ability uses
    bardAbilityDelayMs = 8000,
    
    # List the bard songs you wish to use. 
    # 0 = Default, do nothing
    # 1 = Peacemaking (Resilience, Perseverance)
    # 2 = Provocation (Inspire, Invigorate)
    # 3 = Discord (does nothing)
    useBardSongs = 2,
    
    # Use the Magery Protection spell. Casts when no nearby enemies.
    useProtection = 1,
    
    # EXPERIMENTAL: Does not work great. Would recommend not using this.
    # Whether to honor a nearby enemy to gain the perfection buff.
    # Will try to find an enemy at full health when the buff doesnt exist on player.
    useHonor = 0,
    
    # If greater than 0 will attempt to use bag of sending when this much gold is present. Default is 0, no bag of sending usage.
    minGold = 45000,
    
    # Milliseonds of extra delay when computing cast time to account for internet fuzz. Fine tune this as needed.
    latencyMs = 250
)
