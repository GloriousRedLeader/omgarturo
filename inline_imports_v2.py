#!/usr/bin/env python3
"""
Simple inline imports tool that recursively resolves dependencies.
"""

import ast
import pathlib
from typing import Dict, Set, List, Optional, Tuple
import os
from datetime import datetime

def generate_standard_header():
    """Generate the standard header with today's date."""
    today = datetime.now().strftime("%Y-%m-%d")
    return """# Razor Enhanced Scripts for Ultima Online by
#   GRL  
#   https://github.com/GloriousRedLeader/omgarturo
#   {}
# Use at your own risk. 
#
# This file was auto-generated by the import inliner.
# Original dependencies from fm_core have been inlined below.
""".format(today)

def collect_names_used(node: ast.AST) -> Set[str]:
    """Collect all names that are referenced (loaded) in this AST node."""
    names = set()
    for child in ast.walk(node):
        if isinstance(child, ast.Name) and isinstance(child.ctx, ast.Load):
            names.add(child.id)
    return names

def collect_names_defined(tree: ast.AST) -> Dict[str, ast.AST]:
    """Collect all names defined at module level in this module."""
    defined = {}
    
    # Only look at top-level statements, not inside functions/classes
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            defined[node.name] = node
        elif isinstance(node, ast.ClassDef):
            defined[node.name] = node
        elif isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name):
                    defined[target.id] = node
        elif isinstance(node, ast.AnnAssign) and isinstance(node.target, ast.Name):
            defined[node.target.id] = node
    
    return defined

def collect_imports(tree: ast.AST) -> Dict[str, str]:
    """Collect import mappings: symbol_name -> module_name"""
    imports = {}
    
    for node in ast.walk(tree):
        if isinstance(node, ast.ImportFrom):
            if node.module and not node.module.startswith('Scripts.'):
                continue  # Only process local imports
            if node.names[0].name == '*':
                continue  # Skip star imports
            
            for alias in node.names:
                symbol_name = alias.asname if alias.asname else alias.name
                module_name = node.module
                imports[symbol_name] = module_name
        elif isinstance(node, ast.Import):
            for alias in node.names:
                if not alias.name.startswith('Scripts.'):
                    continue  # Only process local imports
                symbol_name = alias.asname if alias.asname else alias.name.split('.')[-1]
                imports[symbol_name] = alias.name
    
    return imports

class SimpleInliner:
    def __init__(self):
        self.module_cache = {}  # path -> (tree, defined_names, imports)
        self.collected_code = {}  # (module_path, symbol_name) -> ast_node
        self.processed = set()  # (module_path, symbol_name)
        
    def resolve_module_path(self, module_name: str) -> Optional[pathlib.Path]:
        """Convert module name to file path."""
        if not module_name.startswith('Scripts.omgarturo.'):
            return None
            
        # Scripts.omgarturo.fm_core.core_gathering -> fm_core/core_gathering.py
        parts = module_name.split('.')
        if len(parts) < 3:
            return None
            
        rel_path = '/'.join(parts[2:]) + '.py'
        full_path = pathlib.Path(rel_path)
        
        if full_path.exists():
            return full_path
        return None
    
    def load_module(self, module_path: pathlib.Path) -> Tuple[ast.AST, Dict[str, ast.AST], Dict[str, str]]:
        """Load and parse a module, with caching."""
        if module_path in self.module_cache:
            return self.module_cache[module_path]
            
        try:
            with open(module_path, 'r') as f:
                source = f.read()
            tree = ast.parse(source)
            defined_names = collect_names_defined(tree)
            imports = collect_imports(tree)
            
            result = (tree, defined_names, imports)
            self.module_cache[module_path] = result
            return result
        except Exception as e:
            print("Error loading module {}: {}".format(module_path, e))
            return ast.Module(body=[], type_ignores=[]), {}, {}
    
    def collect_symbol_dependencies(self, symbol_name: str, module_path: pathlib.Path, needed_deps: Set[Tuple[pathlib.Path, str]]):
        """Recursively collect all dependencies for a symbol."""
        key = (module_path, symbol_name)
        if key in self.processed:
            return
        self.processed.add(key)
        
        tree, defined_names, imports = self.load_module(module_path)
        
        # Find the symbol definition
        if symbol_name not in defined_names:
            print("Warning: {} not found in {}".format(symbol_name, module_path))
            return
            
        symbol_node = defined_names[symbol_name]
        self.collected_code[key] = symbol_node
        
        # Find what names this symbol uses
        used_names = collect_names_used(symbol_node)
        
        # UO API built-ins and Python built-ins
        builtins = {
            'True', 'False', 'None', 'len', 'range', 'str', 'int', 'float', 'bool', 
            'list', 'dict', 'set', 'tuple', 'print', 'isinstance', 'hasattr', 'getattr', 
            'enumerate', 'zip', 'min', 'max', 'sum', 'abs', 'open', 'Exception', 
            'ValueError', 'TypeError', 'AttributeError', 'KeyError', 'IndexError',
            'Items', 'Player', 'Gumps', 'Misc', 'Target', 'Timer', 'Journal', 
            'Mobiles', 'Spells', 'PathFinding', 'Statics'
        }
        
        # For each used name, check if it's defined locally or imported
        for used_name in used_names:
            # Skip built-ins
            if used_name in builtins:
                continue
                
            if used_name in defined_names:
                # It's defined in the same module
                needed_deps.add((module_path, used_name))
                self.collect_symbol_dependencies(used_name, module_path, needed_deps)
            elif used_name in imports:
                # It's imported from another module
                import_module = imports[used_name]
                import_path = self.resolve_module_path(import_module)
                if import_path:
                    needed_deps.add((import_path, used_name))
                    self.collect_symbol_dependencies(used_name, import_path, needed_deps)
            else:
                # It's not defined locally and not imported - might be a missing dependency
                # or a parameter/local variable, so we don't error here
                pass
    
    def inline_file(self, input_file: pathlib.Path, output_file: pathlib.Path):
        """Process a single file and create inlined version."""
        print("Processing {}...".format(input_file.name))
        
        # Clear dependency tracking for this file (but keep module cache)
        self.collected_code = {}
        self.processed = set()
        
        # Load the original file
        with open(input_file, 'r') as f:
            source = f.read()
        
        tree = ast.parse(source)
        imports = collect_imports(tree)
        
        # Collect all dependencies
        needed_deps = set()
        for symbol_name, module_name in imports.items():
            module_path = self.resolve_module_path(module_name)
            if module_path:
                needed_deps.add((module_path, symbol_name))
                self.collect_symbol_dependencies(symbol_name, module_path, needed_deps)
        
        print("  Found {} total dependencies for {}".format(len(needed_deps), input_file.name))
        
        # Build the inlined code
        inlined_parts = []
        
        # Collect all imports - both from original file and from inlined modules
        all_imports = set()
        
        # Add original imports (non-local ones)
        for node in tree.body:
            if isinstance(node, (ast.Import, ast.ImportFrom)):
                if isinstance(node, ast.ImportFrom):
                    if node.module and node.module.startswith('Scripts.'):
                        continue  # Skip local imports - these will be inlined
                elif isinstance(node, ast.Import):
                    if any(alias.name.startswith('Scripts.') for alias in node.names):
                        continue  # Skip local imports - these will be inlined
                # Keep all other imports (System imports, etc.)
                import_str = ast.unparse(node)
                all_imports.add(import_str)
        
        # Add imports from inlined modules
        processed_modules = set()
        for (module_path, symbol_name) in needed_deps:
            if module_path in processed_modules:
                continue
            processed_modules.add(module_path)
            
            _, _, module_imports = self.load_module(module_path)
            # Add System and other non-local imports from this module
            module_tree, _, _ = self.load_module(module_path)
            for node in module_tree.body:
                if isinstance(node, (ast.Import, ast.ImportFrom)):
                    if isinstance(node, ast.ImportFrom):
                        if node.module and node.module.startswith('Scripts.'):
                            continue  # Skip local imports
                    elif isinstance(node, ast.Import):
                        if any(alias.name.startswith('Scripts.') for alias in node.names):
                            continue  # Skip local imports
                    # Keep System imports, standard library imports, etc.
                    import_str = ast.unparse(node)
                    all_imports.add(import_str)
        
        # Add all collected imports
        inlined_parts.extend(sorted(all_imports))
        
        # Organize collected symbols by type
        constant_nodes = []
        function_nodes = []
        class_nodes = []
        
        for (module_path, symbol_name) in needed_deps:
            if (module_path, symbol_name) in self.collected_code:
                symbol_node = self.collected_code[(module_path, symbol_name)]
                
                if isinstance(symbol_node, ast.FunctionDef):
                    function_nodes.append((symbol_name, symbol_node))
                elif isinstance(symbol_node, ast.ClassDef):
                    class_nodes.append((symbol_name, symbol_node))
                elif isinstance(symbol_node, ast.Assign):
                    constant_nodes.append((symbol_name, symbol_node))
                else:
                    # Other types (like complex expressions)
                    constant_nodes.append((symbol_name, symbol_node))
        
        # Topologically sort all symbols considering cross-dependencies
        sorted_symbols = self._topologically_sort_all_symbols(constant_nodes, function_nodes, class_nodes)
        
        # Build organized code sections with professional formatting
        code_sections = []
        
        # Add standard header
        code_sections.append(generate_standard_header().rstrip())
        code_sections.append('')  # Blank line after header
        
        # Add imports section
        if all_imports:
            code_sections.append('# ===============================================')
            code_sections.append('# External Imports')
            code_sections.append('# ===============================================')
            code_sections.extend(sorted(all_imports))
            code_sections.append('')  # Blank line after imports
        
        # Add inlined symbols in topological order
        if sorted_symbols:
            code_sections.append('# ===============================================')
            code_sections.append('# Inlined Dependencies (topologically sorted)')
            code_sections.append('# ===============================================')
            code_sections.append('')
            
            # Add symbols with proper spacing
            for i, symbol_code in enumerate(sorted_symbols):
                code_sections.append(symbol_code)
                # Add blank line between symbols for readability
                if i < len(sorted_symbols) - 1:
                    code_sections.append('')
            
            code_sections.append('')  # Blank line after inlined code
        
        # Add original code (excluding import statements) with preserved formatting
        if tree.body:
            # Find the original source lines for non-import statements
            original_lines = source.splitlines()
            original_code_lines = []
            
            # Collect all import line numbers to skip
            import_line_nums = set()
            for node in tree.body:
                if isinstance(node, (ast.Import, ast.ImportFrom)):
                    start_line = getattr(node, 'lineno', 1) - 1
                    end_line = getattr(node, 'end_lineno', start_line + 1) - 1
                    for line_num in range(start_line, end_line + 1):
                        import_line_nums.add(line_num)
            
            # Debug: show what import lines we're skipping
            print("  Skipping import lines: {}".format(sorted(import_line_nums)))
            
            # Collect all non-import lines (excluding header which we already added)
            main_code_lines = []
            skip_header = True
            
            for i, line in enumerate(original_lines):
                # Skip the original header (first few comment lines)
                if skip_header and line.strip().startswith('#'):
                    continue
                elif skip_header and not line.strip():
                    continue  # Skip blank lines after header
                else:
                    skip_header = False
                
                # Include non-import lines
                if i not in import_line_nums:
                    main_code_lines.append(line)
            
            if main_code_lines:
                # Remove leading/trailing blank lines
                while main_code_lines and not main_code_lines[0].strip():
                    main_code_lines.pop(0)
                while main_code_lines and not main_code_lines[-1].strip():
                    main_code_lines.pop()
                
                if main_code_lines:
                    code_sections.append('# ===============================================')
                    code_sections.append('# Main Script Code')
                    code_sections.append('# ===============================================')
                    code_sections.extend(main_code_lines)
        
        # Combine everything
        final_code = '\n'.join(code_sections)
        
        # Write output
        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, 'w') as f:
            f.write(final_code + '\n')
        
        print("Wrote {}".format(output_file))
    
    def _topologically_sort_all_symbols(self, constant_nodes, function_nodes, class_nodes):
        """Topologically sort all symbols (constants, functions, classes) based on their dependencies."""
        # Build combined symbol dictionary with source info
        all_symbols = {}
        symbol_sources = {}  # name -> (module_path, symbol_name)
        
        for name, node in constant_nodes + function_nodes + class_nodes:
            all_symbols[name] = node
            # Find the source module for this symbol
            for (module_path, symbol_name) in self.collected_code:
                if symbol_name == name and self.collected_code[(module_path, symbol_name)] == node:
                    symbol_sources[name] = (module_path, symbol_name)
                    break
        
        # Build dependency graph
        dependencies = {}
        symbol_types = {}
        
        for name, node in constant_nodes + function_nodes + class_nodes:
            deps = set()
            # Find what names this symbol references
            for child in ast.walk(node):
                if isinstance(child, ast.Name) and isinstance(child.ctx, ast.Load):
                    if child.id in all_symbols and child.id != name:
                        deps.add(child.id)
                # Also check for function/class calls
                elif isinstance(child, ast.Call) and isinstance(child.func, ast.Name):
                    if child.func.id in all_symbols and child.func.id != name:
                        deps.add(child.func.id)
            dependencies[name] = deps
            
            # Track symbol type
            if isinstance(node, ast.Assign):
                symbol_types[name] = 'constant'
            elif isinstance(node, ast.FunctionDef):
                symbol_types[name] = 'function'
            elif isinstance(node, ast.ClassDef):
                symbol_types[name] = 'class'
            else:
                symbol_types[name] = 'constant'  # fallback
        
        # Topological sort using Kahn's algorithm
        sorted_symbols = []
        remaining = set(all_symbols.keys())
        
        iteration = 0
        while remaining and iteration < 200:  # Prevent infinite loops
            iteration += 1
            
            # Find symbols with no dependencies among remaining symbols
            ready = []
            for name in remaining:
                remaining_deps = dependencies[name] & remaining
                if not remaining_deps:  # No unresolved dependencies
                    ready.append(name)
            
            if not ready:
                # Debug circular dependency
                print("Circular dependency detected at iteration {}".format(iteration))
                print("Remaining symbols: {}".format(sorted(remaining)))
                for name in list(remaining)[:5]:  # Show first 5
                    remaining_deps = dependencies[name] & remaining
                    print("  {} depends on: {}".format(name, sorted(remaining_deps)))
                # Take one arbitrarily to break the cycle
                ready = [next(iter(remaining))]
                print("Breaking cycle by adding: {}".format(ready[0]))
            
            # Add ready symbols in topological order
            for name in sorted(ready):  # Sort for consistency within each iteration
                symbol_node = all_symbols[name]
                
                # Get original source with comments preserved
                if name in symbol_sources:
                    module_path, symbol_name = symbol_sources[name]
                    
                    # Try to get original source with comments
                    try:
                        with open(module_path, 'r') as f:
                            module_text = f.read()
                        lines = module_text.splitlines()
                        start_line = getattr(symbol_node, 'lineno', 1) - 1
                        end_line = getattr(symbol_node, 'end_lineno', start_line + 1)
                        symbol_source_lines = lines[start_line:end_line]
                        symbol_code = '\n'.join(symbol_source_lines)
                    except:
                        # Fallback to AST unparsing if source reading fails
                        symbol_code = ast.unparse(symbol_node)
                    
                    # Add source comment
                    source_comment = "# {} (from {})".format(name, module_path.name)
                    symbol_code = source_comment + '\n' + symbol_code
                else:
                    symbol_code = ast.unparse(symbol_node)
                
                sorted_symbols.append(symbol_code)
                remaining.remove(name)
        
        return sorted_symbols

def validate_imports(output_dir: pathlib.Path):
    """Try to actually import generated files to catch NameError issues."""
    print("\n" + "="*50)
    print("IMPORT VALIDATION: Testing actual imports...")
    print("="*50)
    
    import sys
    import importlib.util
    import tempfile
    import os
    
    import_errors = {}
    original_path = sys.path.copy()
    original_dont_write_bytecode = sys.dont_write_bytecode
    
    try:
        # Prevent Python from creating __pycache__ folders
        sys.dont_write_bytecode = True
        # Add output directory to Python path
        sys.path.insert(0, str(output_dir.absolute()))
        
        for py_file in output_dir.glob('*.py'):
            module_name = py_file.stem
            try:
                spec = importlib.util.spec_from_file_location(module_name, py_file)
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    # Try to execute the module to catch NameError issues
                    spec.loader.exec_module(module)
            except NameError as e:
                error_msg = str(e)
                # Filter out UO API NameErrors - these are expected
                uo_api_names = {
                    'Items', 'Player', 'Gumps', 'Misc', 'Target', 'Timer', 'Journal', 
                    'Mobiles', 'Spells', 'PathFinding', 'Statics'
                }
                is_uo_api_error = any("name '{}' is not defined".format(api) in error_msg for api in uo_api_names)
                
                if not is_uo_api_error:
                    import_errors[py_file.name] = "NameError: {}".format(e)
            except Exception as e:
                # Only report NameErrors and other critical issues, ignore UO API errors
                error_msg = str(e)
                if "NameError" in error_msg or "not defined" in error_msg:
                    # Filter out UO API errors
                    uo_api_names = {
                        'Items', 'Player', 'Gumps', 'Misc', 'Target', 'Timer', 'Journal', 
                        'Mobiles', 'Spells', 'PathFinding', 'Statics'
                    }
                    is_uo_api_error = any("name '{}' is not defined".format(api) in error_msg for api in uo_api_names)
                    
                    if not is_uo_api_error:
                        import_errors[py_file.name] = "Import error: {}".format(e)
    finally:
        # Restore original settings
        sys.path = original_path
        sys.dont_write_bytecode = original_dont_write_bytecode
    
    if import_errors:
        print("\nâŒ Found import errors in {} files:".format(len(import_errors)))
        for filename, error in sorted(import_errors.items()):
            print("  {}: {}".format(filename, error))
        print("\nTotal files with import errors: {}".format(len(import_errors)))
        return False
    else:
        print("\nâœ… All {} files import successfully!".format(len(list(output_dir.glob('*.py')))))
        return True

def validate_syntax(output_dir: pathlib.Path):
    """Check all generated files for syntax errors."""
    print("\n" + "="*50)
    print("SYNTAX VALIDATION: Checking for compilation errors...")
    print("="*50)
    
    syntax_errors = {}
    import py_compile
    import tempfile
    import os
    
    for py_file in output_dir.glob('*.py'):
        try:
            # Try to compile the file
            with tempfile.NamedTemporaryFile(suffix='.pyc', delete=True) as tmp:
                py_compile.compile(str(py_file), tmp.name, doraise=True)
        except py_compile.PyCompileError as e:
            syntax_errors[py_file.name] = str(e)
        except Exception as e:
            syntax_errors[py_file.name] = "Compilation error: {}".format(e)
    
    if syntax_errors:
        print("\nâŒ Found syntax errors in {} files:".format(len(syntax_errors)))
        for filename, error in sorted(syntax_errors.items()):
            print("  {}: {}".format(filename, error))
        print("\nTotal files with syntax errors: {}".format(len(syntax_errors)))
        return False
    else:
        print("\nâœ… All {} files compile successfully!".format(len(list(output_dir.glob('*.py')))))
        return True

def validate_no_local_imports(output_dir: pathlib.Path):
    """Check that NO generated files contain any Scripts.omgarturo imports."""
    print("\n" + "="*50)
    print("LOCAL IMPORT VALIDATION: Checking for remaining local imports...")
    print("="*50)
    
    import_violations = {}
    
    for py_file in output_dir.glob('*.py'):
        try:
            with open(py_file, 'r') as f:
                content = f.read()
            
            # Check for any Scripts.omgarturo imports
            lines = content.splitlines()
            violations = []
            
            for i, line in enumerate(lines, 1):
                if 'from Scripts.omgarturo' in line or 'import Scripts.omgarturo' in line:
                    violations.append("Line {}: {}".format(i, line.strip()))
            
            if violations:
                import_violations[py_file.name] = violations
                
        except Exception as e:
            print('Error processing {}: {}'.format(py_file.name, e))
    
    if import_violations:
        print("\nâŒ CRITICAL ERROR: Found local imports in {} files!".format(len(import_violations)))
        print("These files are NOT standalone and will fail to run:")
        for filename, violations in sorted(import_violations.items()):
            print("\n  {}:".format(filename))
            for violation in violations:
                print("    {}".format(violation))
        print("\nTotal files with import violations: {}".format(len(import_violations)))
        print("THE INLINER IS BROKEN - IT'S NOT ACTUALLY INLINING!")
        return False
    else:
        print("\nâœ… All {} files are standalone (no local imports)!".format(len(list(output_dir.glob('*.py')))))
        return True

def check_undefined_variables(output_dir: pathlib.Path):
    """Check all generated files for undefined variables."""
    print("\n" + "="*50)
    print("UNDEFINED VARIABLES: Scanning for missing definitions...")
    print("="*50)
    
    undefined_vars = {}
    
    # UO API objects that are automatically available (built-ins)
    uo_builtins = {
        'Items', 'Player', 'Gumps', 'Misc', 'Target', 'Timer', 'Journal', 
        'Mobiles', 'Spells', 'PathFinding', 'Statics'
    }
    
    # Standard Python built-ins
    python_builtins = {
        'True', 'False', 'None', 'len', 'range', 'str', 'int', 'float', 'bool', 
        'list', 'dict', 'set', 'tuple', 'print', 'input', 'type', 'isinstance', 
        'hasattr', 'getattr', 'setattr', 'enumerate', 'zip', 'sorted', 'reversed', 
        'all', 'any', 'min', 'max', 'sum', 'abs', 'round', 'open', 'Exception', 
        'ValueError', 'TypeError', 'AttributeError', 'KeyError', 'IndexError', 
        'ImportError', 'RuntimeError', 'NotImplementedError', 'StopIteration', 
        'GeneratorExit', 'KeyboardInterrupt', 'SystemExit', 'object', 'super', 
        'property', 'staticmethod', 'classmethod', 'iter', 'next', 'map', 
        'filter', 'format', 'repr', 'ord', 'chr', 'bin', 'hex', 'oct', 'divmod', 'pow'
    }
    
    all_builtins = python_builtins | uo_builtins
    
    for py_file in output_dir.glob('*.py'):
        try:
            with open(py_file, 'r') as f:
                source = f.read()
            
            tree = ast.parse(source)
            
            # Collect defined names (only at module level)
            defined = set()
            for node in tree.body:
                if isinstance(node, ast.FunctionDef):
                    defined.add(node.name)
                elif isinstance(node, ast.ClassDef):
                    defined.add(node.name)
                elif isinstance(node, ast.Assign):
                    for target in node.targets:
                        if isinstance(target, ast.Name):
                            defined.add(target.id)
                elif isinstance(node, ast.AnnAssign) and isinstance(node.target, ast.Name):
                    defined.add(node.target.id)
                elif isinstance(node, ast.Import):
                    for alias in node.names:
                        defined.add(alias.asname or alias.name.split('.')[0])
                elif isinstance(node, ast.ImportFrom):
                    if node.names[0].name == '*':
                        continue  # Skip star imports
                    for alias in node.names:
                        defined.add(alias.asname or alias.name)
            
            # Collect referenced names
            referenced = set()
            for node in ast.walk(tree):
                if isinstance(node, ast.Name) and isinstance(node.ctx, ast.Load):
                    referenced.add(node.id)
            
            undefined = referenced - defined - all_builtins
            
            if undefined:
                undefined_vars[py_file.name] = sorted(undefined)
        
        except Exception as e:
            print('Error processing {}: {}'.format(py_file.name, e))
    
    if undefined_vars:
        print("\nâŒ Found undefined variables in {} files:".format(len(undefined_vars)))
        for filename, vars in sorted(undefined_vars.items()):
            print("  {}: {}".format(filename, vars[:10]) + (" ..." if len(vars) > 10 else ""))
        print("\nTotal files with issues: {}".format(len(undefined_vars)))
    else:
        print("\nâœ… All {} files passed validation!".format(len(list(output_dir.glob('*.py')))))
    
    print("="*50)

def main():
    """Process all Python files in the current directory."""
    inliner = SimpleInliner()
    
    # Create output directory
    output_dir = pathlib.Path('build_inlined_v2')
    output_dir.mkdir(exist_ok=True)
    
    # Process all Python files (excluding the inliner itself)
    processed_count = 0
    for py_file in pathlib.Path('.').glob('*.py'):
        if py_file.name.startswith('inline_imports'):
            continue
        if py_file.name.startswith('__'):
            continue
        
        output_file = output_dir / py_file.name
        inliner.inline_file(py_file, output_file)
        processed_count += 1
    
    print("\nProcessed {} files.".format(processed_count))
    
    # Run comprehensive validation
    print("\n" + "="*60)
    print("COMPREHENSIVE VALIDATION")
    print("="*60)
    
    syntax_ok = validate_syntax(output_dir)
    no_local_imports_ok = validate_no_local_imports(output_dir)
    import_ok = validate_imports(output_dir)
    check_undefined_variables(output_dir)  # This is just informational
    
    if syntax_ok and no_local_imports_ok and import_ok:
        print("\nðŸŽ‰ BUILD SUCCESSFUL: All {} files generated and validated!".format(processed_count))
        print("Note: 'Undefined variables' above are mostly function parameters (expected).")
    else:
        print("\nðŸ’¥ BUILD FAILED: Critical errors found in generated files!")
        if not syntax_ok:
            print("  - Syntax errors found")
        if not no_local_imports_ok:
            print("  - LOCAL IMPORTS STILL PRESENT - INLINER IS BROKEN!")
        if not import_ok:
            print("  - Import/NameError issues found (real dependency problems)")
        print("Fix dependency ordering issues before using these scripts.")

if __name__ == '__main__':
    main()
