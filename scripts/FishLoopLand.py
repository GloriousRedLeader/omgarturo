# Razor Enhanced Scripts for Ultima Online by
#   GRL  
#   https://github.com/GloriousRedLeader/omgarturo
#   2025-09-19
# Use at your own risk. 
#
# This file was auto-generated by the import inliner.
# Original dependencies from fm_core have been inlined below.

# ===============================================
# External Imports
# ===============================================
from System import Byte, Int32
from System.Collections.Generic import List
from ctypes import wintypes
import ctypes
import sys
import time

# ##########################################################
# #                                                        #
# #              INLINED DEPENDENCIES                     #
# #                                                        #
# #  DO NOT EDIT THIS SECTION - AUTO-GENERATED CODE       #
# #                                                        #
# #  These are dependencies from fm_core that have been   #
# #  automatically inlined. For user-editable code,       #
# #  scroll down to the bottom of this file.              #
# #                                                        #
# ##########################################################

# BUTCHERS_WAR_CLEAVER_STATIC_ID (from core_items.py)
BUTCHERS_WAR_CLEAVER_STATIC_ID = 0x2D2F

# DAGGER_STATIC_ID (from core_items.py)
DAGGER_STATIC_ID = 0x0F52

# FISHING_POLE_STATIC_IDS (from core_items.py)
FISHING_POLE_STATIC_IDS = [0x0DC0]

# FISH_STATIC_IDS (from core_items.py)
FISH_STATIC_IDS = [
    0x4302, # Demon Trout
    0x4303, # Bonito
    0x4306, # Cape cod
    0x4307, # Red grouper, Shad, gray snapper, red drum, sunfish, redbelly beam, pumpkinseed sunfish
    
    0x09CC, # Bluefish, Haddock, brook trout
    0x09CD, 
    0x09CE, # Black seabass
    0x09CF, # Fish
    
    0x44C3, # Torpon, bonefish
    0x44C4, # Yellowfin tuna, pike
    0x44C5, # Captain snook
    0x44C6, # Mahi-mahi
    
    0x44D1, # Snow crab, Apple crab
    0x44D2, # Blue crab, Dungeness crab
    0x44D3, # Crusty Lobster
    0x44D4, # Hummer lobster
]

# HARVESTERS_BLADE_STATIC_ID (from core_items.py)
HARVESTERS_BLADE_STATIC_ID = 0x2D20

# TRUE_NORTH_DIRECTION_MAP (from core_gathering.py)
TRUE_NORTH_DIRECTION_MAP = ["Forward One", "Right One", "Back One", "Left One"]

# corpseScannerCache (from core_gathering.py)
corpseScannerCache = []

# equip_weapon (from core_player.py)
def equip_weapon(newItem):
    leftHand = Player.GetItemOnLayer("LeftHand")
    if leftHand != None:
        Player.UnEquipItemByLayer("LeftHand", True)    
        Misc.Pause(1000)      
        
    rightHand = Player.GetItemOnLayer("RightHand")        
    if rightHand != None:
        Player.UnEquipItemByLayer("RightHand", True)    
        Misc.Pause(1000)      
    
    Player.EquipItem(newItem)    
    Misc.Pause(1000)      
    return [leftHand, rightHand]

# find_all_in_container_by_ids (from core_player.py)
def find_all_in_container_by_ids(itemIDs, containerSerial = Player.Backpack.Serial):
    items = []
    for itemID in itemIDs:
        items = items + Items.FindAllByID(itemID, -1, containerSerial, 1)
    return items

# find_in_container_by_id (from core_player.py)
def find_in_container_by_id(itemID, containerSerial = Player.Backpack.Serial, color = -1, ignoreContainer = [], recursive = False):
    ignoreColor = False
    if color == -1:
        ignoreColor = True
        
    container = Items.FindBySerial(containerSerial)

    if isinstance( itemID, int ):
        foundItem = next( ( item for item in container.Contains if ( item.ItemID == itemID and ( ignoreColor or item.Hue == color ) ) ), None )
    elif isinstance( itemID, list ):
        foundItem = next( ( item for item in container.Contains if ( item.ItemID in itemID and ( ignoreColor or item.Hue == color ) ) ), None )
    else:
        raise ValueError( 'Unknown argument type for itemID passed to FindItem().', itemID, container )

    if foundItem != None:
        return foundItem        
    elif recursive == True:
        for item in container.Contains:
            if item.IsContainer:
                foundItem = find_in_container_by_id(itemID, containerSerial = item.Serial, color = color, ignoreContainer = ignoreContainer, recursive = recursive)
                if foundItem != None:
                    return foundItem

# find_in_hands_by_id (from core_player.py)
def find_in_hands_by_id(itemID): 
    leftHand = Player.GetItemOnLayer("LeftHand")
    if leftHand != None and leftHand.ItemID == itemID:
        return leftHand
    rightHand = Player.GetItemOnLayer("RightHand")
    if rightHand != None and rightHand.ItemID == itemID:
        return rightHand
    return None

# get_boat_direction (from core_gathering.py)
def get_boat_direction():
    boatDirection = None
    playerX = Player.Position.X
    playerY = Player.Position.Y
    Player.ChatSay("forward one")
    Misc.Pause(1000)
    if Player.Position.X < playerX:
        boatDirection = "West"
        boatDirection = 1
    elif Player.Position.X > playerX:
        boatDirection = "East"        
        boatDirection = 3
    elif Player.Position.Y < playerY:
        boatDirection = "North"                
        boatDirection = 0
    elif Player.Position.Y > playerY:
        boatDirection = "South"  
        boatDirection = 2
    Player.ChatSay("back one")
    Misc.Pause(1000)        

    return boatDirection

# get_corpses (from core_items.py)
def get_corpses(range = 2):
    filter = Items.Filter()
    filter.OnGround = True
    filter.RangeMax = range
    filter.IsCorpse = True
    return Items.ApplyFilter(filter)

# get_tile_in_front (from core_rails.py)
def get_tile_in_front(distance = 1):
    direction = Player.Direction
    playerX = Player.Position.X
    playerY = Player.Position.Y
    playerZ = Player.Position.Z
    
    if direction == 'Up':
        tileX = playerX - distance
        tileY = playerY - distance
        tileZ = playerZ
    elif direction == 'North':
        tileX = playerX
        tileY = playerY - distance
        tileZ = playerZ
    elif direction == 'Right':
        tileX = playerX + distance
        tileY = playerY - distance
        tileZ = playerZ
    elif direction == 'East':
        tileX = playerX + distance
        tileY = playerY
        tileZ = playerZ
    elif direction == 'Down':
        tileX = playerX + distance
        tileY = playerY + distance
        tileZ = playerZ
    elif direction == 'South':
        tileX = playerX
        tileY = playerY + distance
        tileZ = playerZ
    elif direction == 'Left':
        tileX = playerX - distance
        tileY = playerY + distance
        tileZ = playerZ
    elif direction == 'West':
        tileX = playerX - distance
        tileY = playerY
        tileZ = playerZ
    return tileX, tileY, tileZ

# move_item_to_container (from core_player.py)
def move_item_to_container(item, destinationSerial):
    Items.Move(item, destinationSerial, item.Amount)
    Misc.Pause(800)

# find_first_in_container_by_ids (from core_player.py)
def find_first_in_container_by_ids(itemIDs, containerSerial = Player.Backpack.Serial):
    for itemID in itemIDs:
        item = find_in_container_by_id(itemID, containerSerial)
        if item != None:
            return item
    return None

# find_first_in_hands_by_ids (from core_player.py)
def find_first_in_hands_by_ids(itemIDs):
    for itemID in itemIDs:
        item = find_in_hands_by_id(itemID)
        if item != None:
            return item
    return None    

# sail_to_tile (from core_gathering.py)
def sail_to_tile(

    # Go to this X coord
    x, 
    
    # Go to this Y coord
    y, 

    # Result of get_boat_direction. Dont call it in here because it is wasteful.
    # We would have to do it after each corpse is looted.
    boatDirection,
    
    # Optional Time to delay between issuing commands to move boat. This is slow.
    moveCmdLatencyMs = 650
):
    directionMap = TRUE_NORTH_DIRECTION_MAP[boatDirection:] + TRUE_NORTH_DIRECTION_MAP[: boatDirection]
    while True:
        #print("Player ", Player.Position.X, Player.Position.Y)
        if Player.Position.X == x and Player.Position.Y == y:
            break
        if Player.Position.X > x:
            Player.ChatSay(directionMap[3])
        elif Player.Position.X < x:
            Player.ChatSay(directionMap[1])            
        elif Player.Position.Y < y:
            Player.ChatSay(directionMap[2])                        
        elif Player.Position.Y > y:
            Player.ChatSay(directionMap[0])
        Misc.Pause(1000)

# run_fishing_loop (from core_gathering.py)
def run_fishing_loop(

    # (Optional) How many tiles in front of character to cast. Defaults to 4 tiles
    # in front of character.
    fishRange = 4, 
    
    # (Optional) After each cast move the boat forward this many tiles. Useful if on a boat.
    # Just tells the tiller forward one this many times. Default is 0 (stay in same spot). 
    moveTiles = 0, 
    
    # (Optional) How long to pause between casts in ms. Default is 9000ms.
    fishDelayMs = 9000,
    
    # 0 = Do nothing, leave in backpack (default)
    # 1 = cut fish with a tool of your choice to reduce weight, makes lots of fish steaks (see cutToolItemId)
    # 2 = place fish in cargo hold of ship, have to be standing near cargo hold
    fishHandling = 0,
    
    # (Optional) String name of fish you want to keep safe. Will not do any fishHandling operations on this fish. 
    # Leaves it in backpack. Useful if you are doing fish monger quests. Just type the fish name
    # you want to keep in your backpack (lower case). Default is none.
    fishToKeep = None,
    
    # (Optional) The item id (not serial) of the tool you want to use to cut fish. Default is dagger but other
    # shards may have more optimized tools with bonuses. This tool can be in your backpack OR in a container in your
    # backpack, but it wont search any more nested containers after that.
    cutToolItemId = DAGGER_STATIC_ID,
    
    # (Optional) Enable this and you will sail to nearby corpses that match those in corpseNames below. This
    # is useful if you want to look sea serpents for MiBs and such. At present there is no support for auto loot.
    # You need to enable what you want in your auto looter (tazuo or doranas lootmaster).
    # This is very crude. It just sails one tile at a time until it finds a corpse. Then, it pauses for a bit
    # while your autolooter does what it needs to do. It will do this for all nearby corpses before returning to
    # where you started and resume fishing. There are several more options below to customize this behavior.
    useCorpseScanner = False,
    
    # (Optional) Time delay in miliseconds between issuing commands to move boat. Adjust based on your servers latency.
    corpseScannerMoveCommandDelayMs = 650,
    
    # (Optional) Set the number of miliseconds to wait at a corpse once reaching it so your auto looter can do the business.
    corpseScannerPauseDelayMs = 2000,
    
    # (Optional) Array of corpse names. Only sail to loot these. Useful for message in a bottle enemies.
    corpseNames = ["a deep sea serpents corpse", "a sea serpents corpse"],
):
    global corpseScannerCache
    
    fishingPole = find_first_in_hands_by_ids(FISHING_POLE_STATIC_IDS)
    if fishingPole == None:
        fishingPole = find_first_in_container_by_ids(FISHING_POLE_STATIC_IDS)
        if fishingPole == None:
            print("Need a fishing pole")
            return False
        else:
            equip_weapon(fishingPole)
        
    while Player.Weight < Player.MaxWeight - 40:
        # Cut fish they are heavy
        if fishHandling == 1:
            cutTool = Items.FindByID(cutToolItemId, -1, Player.Backpack.Serial, 1)
            #dagger = find_first_in_container_by_ids(DAGGER_STATIC_IDS)
            if cutTool is not None:
                fishies = find_all_in_container_by_ids(FISH_STATIC_IDS)
                for fish in fishies:
                    if fishToKeep is not None and fish.Name.lower().find(fishToKeep.lower()) > -1:
                        Player.HeadMessage(28, "Keeping fish {} item id {}".format(fish.Name, fish.ItemID))
                        continue
                    print("Cutting fish {} item id {}".format(fish.Name, fish.ItemID))
                    Items.UseItem(cutTool)
                    Target.WaitForTarget(1000, False)
                    Target.TargetExecute(fish)
            else:
                print("You have elected to cut fish however no dagger was found in backpack.")
                return
        elif fishHandling == 2:
            fishies = find_all_in_container_by_ids(FISH_STATIC_IDS)
            fil = Items.Filter()
            fil.Name = "cargo hold"
            fil.RangeMax = 3
            hatches = Items.ApplyFilter(fil)
            if len(hatches) > 0:
                for fish in fishies:
                    if fishToKeep is not None and fish.Name.lower().find(fishToKeep.lower()) > -1:
                        Player.HeadMessage(28, "Keeping fish {} item id {}".format(fish.Name, fish.ItemID))
                        continue
                    print("Moving fish {} item id {}".format(fish.Name, fish.ItemID))                        
                    move_item_to_container(fish, hatches[0].Serial)
                    
        Target.Cancel()
        Items.UseItem(fishingPole)
        Target.WaitForTarget(2000, False)
        x, y, z = get_tile_in_front(fishRange)
        
        # The people who made this game made some questionable decisions.
        # If we are in britain, the water tile is the land tile.
        # If we are in tokumo, the water tile is a static tile on top of land tile.
        # So, we will look for something with the "Wet" flag and go from there.
        fished = False
        
        tileInfoList = Statics.GetStaticsTileInfo(x, y, Player.Map)
        if len(tileInfoList) > 0:
            for tileInfo in tileInfoList:
                val = Statics.GetTileFlag(tileInfo.StaticID,"Wet")
                if Statics.GetTileFlag(tileInfo.StaticID,"Wet") == True:
                    print("TargetExecute(x = {}, y = {}, staticZ = {}, staticId = {})".format(x, y, tileInfo.StaticZ, tileInfo.StaticID))
                    Target.TargetExecute(x, y, tileInfo.StaticZ, tileInfo.StaticID)
                    fished = True
                    Misc.Pause(fishDelayMs)
                    break

        if not fished:
            landInfo = Statics.GetStaticsLandInfo(x,y,Player.Map)
            if landInfo is not None:
                val = Statics.GetLandFlag(landInfo.StaticID,"Wet")
                if Statics.GetLandFlag(landInfo.StaticID,"Wet"):
                    Target.TargetExecute(x, y, landInfo.StaticZ)
                    Misc.Pause(fishDelayMs)
                    fished = True
                else:
                    print("This tile is not wet")

        if useCorpseScanner:
            items = get_corpses(range = 10)
            
            if len(items) > 0:
                playerX = Player.Position.X
                playerY = Player.Position.Y
                corpses = List[type(items[0])]([item for item in items if item.Name in corpseNames and item.Serial not in corpseScannerCache])

                if len(corpses) > 0:
                    boatDirection = get_boat_direction()
                    for corpse in corpses:
                        print(corpse.Name, corpse.Position.X, corpse.Position.Y)
                        sail_to_tile(corpse.Position.X, corpse.Position.Y, boatDirection, corpseScannerMoveCommandDelayMs)
                        Misc.Pause(corpseScannerPauseDelayMs)
                        print("cacheLooted size = {}".format(len(corpseScannerCache)))
                        if len(corpseScannerCache) >= 30:
                            corpseScannerCache.pop(0)
                            print("cacheLooted popping one off {}".format(len(corpseScannerCache)))
                        corpseScannerCache.append(corpse.Serial)
                    sail_to_tile(playerX, playerY, boatDirection, corpseScannerMoveCommandDelayMs)               

        for i in range(0, moveTiles):
            Player.ChatSay("forward one")
            Misc.Pause(750)

# ##########################################################
# #                                                        #
# #                 USER EDITABLE CODE                    #
# #                                                        #
# #  This is the original script code that you can        #
# #  modify and customize. Edit the parameters, logic,    #
# #  and function calls below as needed for your setup.   #
# #                                                        #
# #  The dependencies above have been automatically       #
# #  inlined and should not be modified.                  #
# ##########################################################

# ===============================================
# Main Script Code
# ===============================================
# Auto fishes. Works on a boat. Works on a dock. Works if youre on a rock. 
# Take advantage of the moveTiles param to move boat after 
# each fishing attempt. It will say forward one X number of times.
# Can automatically cut fish. Can automatically store fish in hold.
# Can automatically move to nearby corpses so you can loot (this script does not
# loot though).
#
# Setup:
# 1) Read the parameters below and configure as needed.
# 2) If you want to automatically cut fish, you will need a basic dagger in your pack (or provide your own tool).
# 3) If you want to put fish directly in your hold, you will need to stand right on top of it.
# 4) You will need a fishing pole of course.
# 5) The useCorpseScanner feature will sail to nearby corpses so  you dont miss MiBs.
run_fishing_loop(

    # (Optional) How many tiles in front of character to cast. Defaults to 4 tiles
    # in front of character.
    fishRange = 4, 
    
    # (Optional) After each cast move the boat forward this many tiles. Useful if on a boat.
    # Just tells the tiller forward one this many times. Default is 0 (stay in same spot). 
    moveTiles = 0, 
    
    # (Optional) How long to pause between casts in ms. Default is 9000ms.
    fishDelayMs = 9000,
    
    # 0 = Do nothing, leave in backpack
    # 1 = cut fish with a tool of your choice to reduce weight, makes lots of fish steaks (see cutToolItemId)
    # 2 = place fish in cargo hold of ship, have to be standing near cargo hold
    fishHandling = 0,
    
    # (Optional) String name of fish you want to keep safe. Will not do any fishHandling operations on this fish. 
    # Leaves it in backpack. Useful if you are doing fish monger quests. Just type the fish name
    # you want to keep in your backpack (lower case). Default is none, but you could enter
    # something like "gray snapper"
    fishToKeep = None,
    
    # (Optional) The item id (not serial) of the tool you want to use to cut fish. Default is dagger but other
    # shards may have more optimized tools with bonuses.
    cutToolItemId = DAGGER_STATIC_ID,
    
    # (Optional) Enable this and you will sail to nearby corpses that match those in corpseNames below. This
    # is useful if you want to look sea serpents for MiBs and such. At present there is no support for auto loot.
    # You need to enable what you want in your auto looter (tazuo or doranas lootmaster).
    # This is very crude. It just sails one tile at a time until it finds a corpse. Then, it pauses for a bit
    # while your autolooter does what it needs to do. It will do this for all nearby corpses before returning to
    # where you started and resume fishing. There are several more options below to customize this behavior.
    useCorpseScanner = False,
    
    # (Optional) Time delay in miliseconds between issuing commands to move boat. Adjust based on your servers latency.
    corpseScannerMoveCommandDelayMs = 650,
    
    # (Optional) Set the number of miliseconds to wait at a corpse once reaching it so your auto looter can do the business.
    corpseScannerPauseDelayMs = 2000,
    
    # (Optional) Array of corpse names. Only sail to loot these. Useful for message in a bottle enemies.
    corpseNames = ["a deep sea serpents corpse", "a sea serpents corpse"],
)
