# Razor Enhanced Scripts for Ultima Online by
#   GRL  
#   https://github.com/GloriousRedLeader/omgarturo
#   2025-09-19
# Use at your own risk. 
#
# This file was auto-generated by the import inliner.
# Original dependencies from fm_core have been inlined below.

# ===============================================
# External Imports
# ===============================================
from System import Byte, Int32
from System.Collections.Generic import List
from ctypes import wintypes
import ctypes
import sys
import time

# ##########################################################
# #                                                        #
# #              INLINED DEPENDENCIES                     #
# #                                                        #
# #  DO NOT EDIT THIS SECTION - AUTO-GENERATED CODE       #
# #                                                        #
# #  These are dependencies from fm_core that have been   #
# #  automatically inlined. For user-editable code,       #
# #  scroll down to the bottom of this file.              #
# #                                                        #
# ##########################################################

# ANIMATE_DEAD_MOBILE_NAMES (from core_mobiles.py)
ANIMATE_DEAD_MOBILE_NAMES = [
    "a gore fiend",
    "a lich",
    "a flesh golem",
    "a mummy",
    "a skeletal dragon",
    "a lich lord",
    "a skeletal knight",
    "a bone knight",
    "a skeletal mage",
    "a bone mage",
    "a patchwork skeleton",
    "a mound of maggots",
    "a wailing banshee",
    "a wraith",
    "a hellsteed",
    "a skeletal steed",
    "an Undead Gargoyle",
    "a skeletal drake",
    "a putrid undead gargoyle",
    "a blade spirit",
    "an energy vortex",
    "a skeletal drake"
]

# go_to_tile (from core_rails.py)
def go_to_tile(
    # Desired X coordinate to travel to. Typically a mobile X.
    x, 
    
    # Desired Y coordinate to travel to. Typically a mobile Y.
    y, 
    
    # Number of seconds to attempt travel. Blocks until we arrive or this many seconds elapses.
    timeoutSeconds = -1, 
    
    # Value of 0 means land right on x, y. This is the default behavior. Positive value means stop 
    # short of the provided x, y by that many tiles. This is useful for casters or anyone who 
    # doesnt wish to be directly on top of a mobile.
    tileOffset = 0
):
    if Player.Position.X == x and Player.Position.Y == y:
        return True
        
    start_time = time.time()
    
    if tileOffset > 0:
        tiles = PathFinding.GetPath(x, y, True)
        numTiles = len(tiles) if tiles is not None else 0
        
        if numTiles - tileOffset > 1:
            # There is a duplicate of last tile entry. Its in there twice.
            tileIndex = numTiles - tileOffset - 2
            x = tiles[tileIndex].X
            y = tiles[tileIndex].Y
        else:
            return True
        
    route = PathFinding.Route() 
    route.X = x
    route.Y = y
    route.MaxRetry = 3
    route.IgnoreMobile = True
    route.Timeout = timeoutSeconds
    res = PathFinding.Go(route)
    
    #total = "{:.2f}".format(time.time() - start_time)
    return res  

# railsEarnedGold (from core_rails.py)
railsEarnedGold = 0

# railsLastGold (from core_rails.py)
railsLastGold = 0

# railsStartingTime (from core_rails.py)
railsStartingTime = 0

# get_enemies (from core_mobiles.py)
def get_enemies(range = 10, serialsToExclude = []):
    fil = Mobiles.Filter()
    fil.Enabled = True
    fil.RangeMax = range
    fil.Notorieties = List[Byte](bytes([3,4,5,6]))
    fil.IsGhost = False
    fil.Friend = False
    fil.CheckLineOfSight = True
    mobs = Mobiles.ApplyFilter(fil)
    
    # need to remove Animate dead summons. There are a handfull of MobileIDs that match
    # the regular mobs, however these are red from animate dead when they are normally gray.
    if len(mobs) > 0:
        #for mob in mobs:
            #print(mob.Name, mob.Name not in ANIMATE_DEAD_MOBILE_NAMES and mob.Notoriety != 6 and mob.Serial not in serialsToExclude)
            #print("is in animate dead", mob.Name not in ANIMATE_DEAD_MOBILE_NAMES)
            
        mobsList = List[type(mobs[0])]([mob for mob in mobs if not (mob.Name in ANIMATE_DEAD_MOBILE_NAMES and mob.Notoriety == 6) and mob.Serial not in serialsToExclude])
#        if len(mobsList) == 0:
#            print("No mobs found")
        return mobsList

    return mobs

# rails_stats (from core_rails.py)
def rails_stats(option):
    global railsStartingTime
    global railsEarnedGold
    global railsLastGold
    
    if option == "clear" or option == "start" or option == "reset":
        railsStartingTime = time.time()       
        railsEarnedGold = 0
        railsLastGold = Player.Gold
    elif option == "report_head" or option == "report":
        hours = (time.time() - railsStartingTime) / 60 / 60
        if  Player.Gold < railsLastGold:
            railsEarnedGold = railsEarnedGold + Player.Gold
            railsLastGold = Player.Gold
        elif railsLastGold != Player.Gold:
            railsEarnedGold = railsEarnedGold + Player.Gold - railsLastGold
            railsLastGold = Player.Gold
        timeMinutes =round((time.time() - railsStartingTime) / 60)
        
        if hours == 0:
            goldPerHour = 0
        else:
            goldPerHour = "{:,.0f}".format(railsEarnedGold / hours)

        if Timer.Check("railsStatsTimer") == False:
            message = "Gold Earned: {} Minutes: {} GPH: {}".format( "{:,.0f}".format(railsEarnedGold), timeMinutes, goldPerHour)
            Misc.SendMessage(message, 253)    
            Timer.Create("railsStatsTimer", 15000)

# run_defend_loop (from core_rails.py)
def run_defend_loop(

    # range is the number of tiles to search for monsters in each "sector"
    range = 6, 
    
    # autoLootBufferMs is the time in MS to stand around like an idiot before moving
    autoLootBufferMs = 0, 
    
    # pathFindingTimeoutSeconds is a float that represents number of seconds before quitting
    # on a path. It is a value passed to the pathfinding method. The Pathfinding algorithm 
    # could go on for days. Instead of derping, just give up after this many seconds and 
    # move on with your life.
    pathFindingTimeoutSeconds = 3.0,
    
    # Value of 0 means land right on x, y. This is the default behavior. Positive value means stop 
    # short of the provided x, y by that many tiles. This is useful for casters or anyone who 
    # doesnt wish to be directly on top of a mobile.
    tileOffset = 0    
):
    rails_stats("start")   
    
    while not Player.IsGhost:
        rails_stats("report_head")
        Misc.Pause(2000)
        
        eligible = get_enemies(range) 
        if len(eligible) > 0:  
            Player.HeadMessage(48, "Found {} things to attack".format(len(eligible)))    
            nearest = Mobiles.Select(eligible, 'Nearest')
            
            while Mobiles.FindBySerial(nearest.Serial) is not None and Player.DistanceTo(nearest)<=range:            
                Mobiles.Message(nearest,68,"^ {} tiles ^".format(Player.DistanceTo(nearest)),False)
                
                res = go_to_tile(nearest.Position.X, nearest.Position.Y, pathFindingTimeoutSeconds, tileOffset)
                
                Misc.Pause(250)
            
            # Pause a little longer if we are prioritizing gold so the auto looter can have a moment
            # dont do this in shitty places like deceipt.
            # The check for goToNearestAttempts is a general rule that tells us whether the monster
            # got away or not. It is more likely that there is loot and the monster is dead if attempts 
            # is greater than zero.
            if autoLootBufferMs > 0 and goToNearestAttempts > 0:
                Player.HeadMessage(48, "Pausing a little extra for more loot")
                Misc.Pause(autoLootBufferMs)
        else:
            Player.HeadMessage(48, "Nothing left in sector")
            Misc.Pause(1000)

# ##########################################################
# #                                                        #
# #                 USER EDITABLE CODE                    #
# #                                                        #
# #  This is the original script code that you can        #
# #  modify and customize. Edit the parameters, logic,    #
# #  and function calls below as needed for your setup.   #
# #                                                        #
# #  The dependencies above have been automatically       #
# #  inlined and should not be modified.                  #
# ##########################################################

# ===============================================
# Main Script Code
# ===============================================
Player.HeadMessage(48, "Starting Rail Loop Defend!")

# Stays put until an enemy comes into range, then moves to it.
# Useful if you are at a champ for example. No need for a specific
# set of route coordinates, just stand still and wait until a mob
# happens by.
run_defend_loop(

    # range is the number of tiles to search for monsters in each "sector"
    range = 5, 
    
    # autoLootBufferMs is the time in MS to stand around like an idiot before moving
    autoLootBufferMs = 0, 
    
    # pathFindingTimeoutSeconds is a float that represents number of seconds before quitting
    # on a path. It is a value passed to the pathfinding method. The Pathfinding algorithm 
    # could go on for days. Instead of derping, just give up after this many seconds and 
    # move on with your life.
    pathFindingTimeoutSeconds = 3.0,
    
    # Value of 0 means land right on x, y. This is the default behavior. Positive value means stop 
    # short of the provided x, y by that many tiles. This is useful for casters or anyone who 
    # doesnt wish to be directly on top of a mobile.
    tileOffset = 0    
)
