# Razor Enhanced Scripts for Ultima Online by
#   GRL  
#   https://github.com/GloriousRedLeader/omgarturo
#   2025-09-19
# Use at your own risk. 
#
# This file was auto-generated by the import inliner.
# Original dependencies from fm_core have been inlined below.

# ===============================================
# External Imports
# ===============================================
from System import Byte, Int32
from System.Collections.Generic import List
from ctypes import wintypes
import ctypes
import sys
import time

# ##########################################################
# #                                                        #
# #              INLINED DEPENDENCIES                     #
# #                                                        #
# #  DO NOT EDIT THIS SECTION - AUTO-GENERATED CODE       #
# #                                                        #
# #  These are dependencies from fm_core that have been   #
# #  automatically inlined. For user-editable code,       #
# #  scroll down to the bottom of this file.              #
# #                                                        #
# ##########################################################

# ANIMATE_DEAD_MOBILE_NAMES (from core_mobiles.py)
ANIMATE_DEAD_MOBILE_NAMES = [
    "a gore fiend",
    "a lich",
    "a flesh golem",
    "a mummy",
    "a skeletal dragon",
    "a lich lord",
    "a skeletal knight",
    "a bone knight",
    "a skeletal mage",
    "a bone mage",
    "a patchwork skeleton",
    "a mound of maggots",
    "a wailing banshee",
    "a wraith",
    "a hellsteed",
    "a skeletal steed",
    "an Undead Gargoyle",
    "a skeletal drake",
    "a putrid undead gargoyle",
    "a blade spirit",
    "an energy vortex",
    "a skeletal drake"
]

# deceipt_1_full (from core_routes.py)
deceipt_1_full = [[5187, 623], [5187, 616], [5177, 616], [5187, 616], [5197, 616], [5187, 616], [5187, 605], [5187, 598], [5176, 598], [5187, 598], [5196, 598], [5200, 603], [5192, 599], [5187, 599], [5187, 586], [5187, 578], [5190, 571], [5188, 568], [5188, 567], [5188, 554], [5188, 541], [5176, 541], [5176, 554], [5169, 557], [5164, 562], [5164, 571], [5171, 571], [5170, 557], [5177, 552], [5177, 542], [5187, 542], [5187, 558], [5190, 558], [5191, 558], [5210, 558], [5210, 542], [5210, 532], [5219, 532], [5219, 546], [5219, 557], [5219, 569], [5219, 581], [5219, 564], [5219, 547], [5219, 531], [5204, 529], [5185, 529], [5169, 529], [5169, 541], [5159, 552], [5147, 557], [5146, 573], [5146, 585], [5146, 601], [5146, 614], [5147, 622], [5146, 607], [5147, 592], [5147, 576], [5146, 561], [5153, 552], [5161, 552], [5161, 541], [5170, 541], [5170, 529], [5188, 529], [5205, 529], [5210, 529], [5210, 547], [5210, 559], [5195, 558], [5194, 558], [5193, 558], [5192, 558], [5186, 561], [5187, 566], [5187, 567], [5189, 570], [5191, 577], [5187, 581], [5187, 594], [5187, 612]]

# deceipt_2_full (from core_routes.py)
deceipt_2_full = [[5306, 535], [5306, 546], [5316, 546], [5325, 546], [5333, 546], [5327, 540], [5315, 548], [5299, 548], [5291, 543], [5284, 543], [5284, 549], [5284, 550], [5284, 551], [5284, 562], [5284, 573], [5284, 574], [5284, 581], [5291, 581], [5293, 579], [5294, 579], [5295, 579], [5303, 579], [5309, 579], [5310, 579], [5313, 579], [5315, 588], [5322, 588], [5322, 589], [5322, 590], [5322, 603], [5314, 603], [5313, 603], [5312, 603], [5303, 603], [5296, 610], [5298, 598], [5307, 607], [5310, 604], [5311, 604], [5318, 603], [5323, 603], [5323, 618], [5323, 627], [5316, 627], [5306, 627], [5305, 627], [5304, 627], [5299, 627], [5296, 623], [5299, 623], [5301, 626], [5302, 627], [5303, 627], [5323, 627], [5323, 618], [5339, 618], [5339, 601], [5339, 588], [5339, 582], [5346, 586], [5339, 589], [5339, 606], [5339, 619], [5322, 619], [5322, 601], [5322, 594], [5322, 593], [5322, 592], [5322, 588], [5314, 588], [5314, 579], [5313, 579], [5312, 579], [5298, 579], [5297, 579], [5296, 579], [5283, 579], [5283, 577], [5283, 576], [5283, 557], [5283, 553], [5283, 552], [5283, 544], [5294, 547], [5307, 547], [5307, 537]]

# go_to_tile (from core_rails.py)
def go_to_tile(
    # Desired X coordinate to travel to. Typically a mobile X.
    x, 
    
    # Desired Y coordinate to travel to. Typically a mobile Y.
    y, 
    
    # Number of seconds to attempt travel. Blocks until we arrive or this many seconds elapses.
    timeoutSeconds = -1, 
    
    # Value of 0 means land right on x, y. This is the default behavior. Positive value means stop 
    # short of the provided x, y by that many tiles. This is useful for casters or anyone who 
    # doesnt wish to be directly on top of a mobile.
    tileOffset = 0
):
    if Player.Position.X == x and Player.Position.Y == y:
        return True
        
    start_time = time.time()
    
    if tileOffset > 0:
        tiles = PathFinding.GetPath(x, y, True)
        numTiles = len(tiles) if tiles is not None else 0
        
        if numTiles - tileOffset > 1:
            # There is a duplicate of last tile entry. Its in there twice.
            tileIndex = numTiles - tileOffset - 2
            x = tiles[tileIndex].X
            y = tiles[tileIndex].Y
        else:
            return True
        
    route = PathFinding.Route() 
    route.X = x
    route.Y = y
    route.MaxRetry = 3
    route.IgnoreMobile = True
    route.Timeout = timeoutSeconds
    res = PathFinding.Go(route)
    
    #total = "{:.2f}".format(time.time() - start_time)
    return res  

# hythloth_2 (from core_routes.py)
hythloth_2 = [[5918, 222], [5918, 228], [5918, 233], [5918, 221], [5925, 219], [5926, 219], [5927, 219], [5931, 219], [5931, 211], [5931, 204], [5924, 201], [5923, 205], [5915, 203], [5915, 194], [5915, 187], [5926, 187], [5938, 187], [5938, 179], [5944, 179], [5951, 179], [5962, 179], [5962, 189], [5962, 203], [5955, 209], [5955, 213], [5955, 214], [5955, 218], [5955, 227], [5960, 232], [5955, 219], [5955, 217], [5955, 216], [5962, 200], [5962, 171], [5972, 173], [5986, 169], [5988, 161], [5988, 160], [5987, 154], [5988, 149], [5993, 148], [5988, 154], [5987, 157], [5987, 158], [5987, 171], [5963, 173], [5959, 179], [5939, 181], [5919, 186], [5930, 202], [5930, 220], [5929, 220], [5928, 220], [5924, 220]]

# hythloth_3 (from core_routes.py)
hythloth_3 = [[6093, 155], [6101, 155], [6106, 161], [6106, 170], [6096, 170], [6091, 170], [6088, 176], [6094, 181], [6097, 189], [6097, 207], [6104, 219], [6109, 219], [6110, 219], [6111, 219], [6117, 219], [6117, 224], [6122, 212], [6114, 219], [6113, 219], [6112, 219], [6099, 219], [6099, 203], [6095, 182], [6084, 172], [6081, 171], [6080, 171], [6069, 171], [6058, 171], [6059, 169], [6059, 168], [6059, 167], [6059, 160], [6054, 155], [6059, 164], [6059, 165], [6059, 166], [6059, 167], [6059, 187], [6059, 202], [6049, 203], [6048, 203], [6041, 200], [6036, 196], [6041, 201], [6045, 203], [6046, 203], [6059, 203], [6059, 187], [6059, 170], [6075, 170], [6077, 171], [6078, 171], [6087, 171], [6095, 171], [6107, 171], [6107, 161], [6101, 155], [6093, 155]]

# hythloth_4 (from core_routes.py)
hythloth_4 = []

# new_haven_noob_dungeon (from core_routes.py)
new_haven_noob_dungeon = [[5918, 352], [5916, 344], [5912, 340], [5908, 336], [5909, 333], [5909, 322], [5909, 312], [5909, 307], [5909, 303], [5910, 299], [5913, 297], [5916, 290], [5916, 286], [5922, 283], [5928, 283], [5932, 283], [5932, 279], [5935, 279], [5939, 278], [5944, 278], [5954, 278], [5957, 277], [5962, 277], [5970, 278], [5976, 284], [5980, 283], [5986, 288], [5989, 296], [5993, 301], [5994, 310], [5992, 313], [5992, 317], [5993, 319], [5994, 323], [5994, 329], [5994, 338], [5991, 338], [5988, 342], [5988, 342], [5988, 352], [5978, 356], [5970, 359], [5970, 359], [5967, 362], [5959, 362], [5948, 362], [5943, 362], [5938, 362], [5934, 362], [5930, 357], [5924, 353], [5917, 353]]

# new_haven_skeleton_town (from core_routes.py)
new_haven_skeleton_town = [[3646, 2559], [3650, 2550], [3650, 2540], [3661, 2540], [3640, 2540], [3650, 2535], [3650, 2522], [3660, 2517], [3674, 2517], [3681, 2517], [3681, 2497], [3681, 2486], [3670, 2486], [3664, 2480], [3655, 2489], [3642, 2485], [3631, 2485], [3624, 2496], [3623, 2505], [3629, 2517], [3645, 2521], [3645, 2540], [3651, 2546], [3650, 2561]]

# railsEarnedGold (from core_rails.py)
railsEarnedGold = 0

# railsLastGold (from core_rails.py)
railsLastGold = 0

# railsStartingTime (from core_rails.py)
railsStartingTime = 0

# tortuga_champ_spawn (from core_routes.py)
tortuga_champ_spawn = [[5724, 3991], [5718, 3997], [5720, 3990], [5725, 3986], [5731, 3988], [5731, 3994], [5725, 3995]]

# vermin_horde_champ_middle (from core_routes.py)
vermin_horde_champ_middle = [[5552, 823], [5560, 819], [5567, 821], [5577, 821], [5585, 821], [5589, 830], [5585, 838], [5583, 847], [5580, 850], [5573, 857], [5567, 856], [5559, 856], [5551, 856], [5545, 854], [5539, 853], [5531, 845], [5529, 838], [5532, 830], [5536, 822], [5544, 822], [5550, 822], [5556, 829], [5562, 829]]

# vermin_horde_champ_top (from core_routes.py)
vermin_horde_champ_top = [[5521, 814], [5526, 809], [5531, 804], [5534, 798], [5539, 793], [5541, 788], [5547, 788], [5553, 785], [5560, 785], [5565, 785], [5568, 788], [5565, 791], [5563, 792], [5562, 793], [5561, 794], [5557, 797], [5552, 797], [5546, 799], [5544, 796], [5544, 790], [5539, 790], [5534, 796], [5533, 802], [5528, 806], [5526, 809], [5521, 814], [5520, 816]]

# get_enemies (from core_mobiles.py)
def get_enemies(range = 10, serialsToExclude = []):
    fil = Mobiles.Filter()
    fil.Enabled = True
    fil.RangeMax = range
    fil.Notorieties = List[Byte](bytes([3,4,5,6]))
    fil.IsGhost = False
    fil.Friend = False
    fil.CheckLineOfSight = True
    mobs = Mobiles.ApplyFilter(fil)
    
    # need to remove Animate dead summons. There are a handfull of MobileIDs that match
    # the regular mobs, however these are red from animate dead when they are normally gray.
    if len(mobs) > 0:
        #for mob in mobs:
            #print(mob.Name, mob.Name not in ANIMATE_DEAD_MOBILE_NAMES and mob.Notoriety != 6 and mob.Serial not in serialsToExclude)
            #print("is in animate dead", mob.Name not in ANIMATE_DEAD_MOBILE_NAMES)
            
        mobsList = List[type(mobs[0])]([mob for mob in mobs if not (mob.Name in ANIMATE_DEAD_MOBILE_NAMES and mob.Notoriety == 6) and mob.Serial not in serialsToExclude])
#        if len(mobsList) == 0:
#            print("No mobs found")
        return mobsList

    return mobs

# rails_stats (from core_rails.py)
def rails_stats(option):
    global railsStartingTime
    global railsEarnedGold
    global railsLastGold
    
    if option == "clear" or option == "start" or option == "reset":
        railsStartingTime = time.time()       
        railsEarnedGold = 0
        railsLastGold = Player.Gold
    elif option == "report_head" or option == "report":
        hours = (time.time() - railsStartingTime) / 60 / 60
        if  Player.Gold < railsLastGold:
            railsEarnedGold = railsEarnedGold + Player.Gold
            railsLastGold = Player.Gold
        elif railsLastGold != Player.Gold:
            railsEarnedGold = railsEarnedGold + Player.Gold - railsLastGold
            railsLastGold = Player.Gold
        timeMinutes =round((time.time() - railsStartingTime) / 60)
        
        if hours == 0:
            goldPerHour = 0
        else:
            goldPerHour = "{:,.0f}".format(railsEarnedGold / hours)

        if Timer.Check("railsStatsTimer") == False:
            message = "Gold Earned: {} Minutes: {} GPH: {}".format( "{:,.0f}".format(railsEarnedGold), timeMinutes, goldPerHour)
            Misc.SendMessage(message, 253)    
            Timer.Create("railsStatsTimer", 15000)

# do_route (from core_rails.py)
def do_route(
    # List of x,y coordinates. Will cycle through sequentially.
    path, 
    
    # If an enemy is found within this many tiles, go to that enemy. Stay there
    # until it is dead. If we cant reach it after x number of tries, quit and go back
    # to normal route.
    range = 6, 
    
    # Pause for this many MS after a mobile we are after dies.
    autoLootBufferMs = 0, 
    
    # Number of seconds to attempt travel. Blocks until we arrive or this many seconds elapses. 
    pathFindingTimeoutSeconds = 3.0,
    
    # Value of 0 means land right on x, y. This is the default behavior. Positive value means stop 
    # short of the provided x, y by that many tiles. This is useful for casters or anyone who 
    # doesnt wish to be directly on top of a mobile.
    tileOffset = 0
):
    sectorId = 0
    for coord in path:
        sectorId = sectorId + 1
        serialsToExclude = []

        while not Player.IsGhost:
            rails_stats("report_head")
            
            if not go_to_tile(coord[0],coord[1], pathFindingTimeoutSeconds):
                Misc.SendMessage("Cant make it to target, aborting this coord", 38)
                break
            
            Misc.Pause(1000)
            eligible = get_enemies(range, serialsToExclude) 

            if len(eligible) > 0:  
                nearest = Mobiles.Select(eligible, 'Nearest')
                goToNearestAttempts = 3
                while Mobiles.FindBySerial(nearest.Serial) is not None and Player.DistanceTo(nearest)<=range:            
                    res = go_to_tile(nearest.Position.X, nearest.Position.Y, pathFindingTimeoutSeconds, tileOffset)
                    Misc.Pause(50)
                    
                    if res == False or (Player.DistanceTo(nearest) > 1 and goToNearestAttempts <= 0):
                        serialsToExclude.append(nearest.Serial)
                        break
                    elif Player.DistanceTo(nearest) > 1:
                        goToNearestAttempts = goToNearestAttempts - 1
                    
                    Misc.Pause(250)
                        
                # Always pause for some amount because the world will end
                rails_stats("report_head")
                Misc.Pause(1000)
                
                # Pause a little longer if we are prioritizing gold so the auto looter can have a moment
                # dont do this in shitty places like deceipt.
                # The check for goToNearestAttempts is a general rule that tells us whether the monster
                # got away or not. It is more likely that there is loot and the monster is dead if attempts 
                # is greater than zero.
                if autoLootBufferMs > 0 and goToNearestAttempts > 0:
                    Misc.Pause(autoLootBufferMs)
            else:
                break

# run_rail_loop (from core_rails.py)
def run_rail_loop(

    # (Required) This is a list of coordinates to travel. See core_routes for a list of available, pre-defined routes.
    # You can generate your own using the rails tool. Its easy. Just load up the script RailRecorder.py
    # and start adding points. Walk to a location, click add point. When youre done hit save. Open the file. It 
    # will contain a list of coordinates you can paste here. Your character will walk around like an idiot.
    path,

    # (Optional) Number of tiles to scan for nearby monsters. If you set this too high it will
    # try to find monsters through walls and in other maps and waste time.
    attackRange = 5,    
    
    # (Optional) Number of seconds to allow before giving up when going from one coord to another.
    # Default is 5 seconds.
    pathFindingTimeoutSeconds = 5.0,
    
    # (Optional) Give a little extra time to loot when a monster dies. This is useful. A nice value
    # is about 2 seconds.
    autoLootBufferMs = 2000,
    
    # (Optional) When a mob is found, your character will move right on top of it. This value governs
    # whether you should stop tileOffset tiles before it. This is useful for casters or anyone who 
    # doesnt wish to be directly on top of a mobile.
    # A value of 0 (default) means land right on the target x, y. Positive value means stop 
    # short of the provided x, y by that many tiles. 
    tileOffset = 0 
):
    rails_stats("start")        

    while not Player.IsGhost:
        if Player.Weight < Player.MaxWeight - 40:
            do_route(path, range = attackRange, autoLootBufferMs = autoLootBufferMs, pathFindingTimeoutSeconds = pathFindingTimeoutSeconds, tileOffset= tileOffset)
            rails_stats("report")
        else:
            Player.HeadMessage(48, "Stopping because max weight reached")
            break

# ##########################################################
# #                                                        #
# #                 USER EDITABLE CODE                    #
# #                                                        #
# #  This is the original script code that you can        #
# #  modify and customize. Edit the parameters, logic,    #
# #  and function calls below as needed for your setup.   #
# #                                                        #
# #  The dependencies above have been automatically       #
# #  inlined and should not be modified.                  #
# ##########################################################

# ===============================================
# Main Script Code
# ===============================================
Player.HeadMessage(48, "Starting Rail Loop")

# Runs a route based on a list of [x, y] coordinates. Will run it repeatadly.
# It is recommended to make those routes a loop that start and end at or
# around the same coordinate since it loops indefinitely.
# You can find a list of coordinates predefined in fm_core/core_routes.py
# If an enemy is found within attackRange (configued below), your character will move
# to that enemy. It will follow it until it is dead or becomes unreachable.
# Use this script in conjunction with AttackLoop or CasterLoop which will do your offense.
run_rail_loop(

    # (Required) This is a list of coordinates to travel. See core_routes for a list of available, pre-defined routes.
    # You can generate your own using the rails tool. Its easy. Just load up the script RailRecorder.py
    # and start adding points. Walk to a location, click add point. When youre done hit save. Open the file. It 
    # will contain a list of coordinates you can paste here. Your character will walk around like an idiot.
    path = new_haven_noob_dungeon,

    # (Optional) Number of tiles to scan for nearby monsters. If you set this too high it will
    # try to find monsters through walls and in other maps and waste time.
    attackRange = 5,    
    
    # (Optional) Number of seconds to allow before giving up when going from one coord to another.
    # Default is 5 seconds.
    pathFindingTimeoutSeconds = 5.0,
    
    # (Optional) Give a little extra time to loot when a monster dies. This is useful. A nice value
    # is about 2 seconds.
    autoLootBufferMs = 2000,
    
    # (Optional) When a mob is found, your character will move right on top of it. This value governs
    # whether you should stop tileOffset tiles before it. This is useful for casters or anyone who 
    # doesnt wish to be directly on top of a mobile.
    # A value of 0 (default) means land right on the target x, y. Positive value means stop 
    # short of the provided x, y by that many tiles. 
    tileOffset = 0 
)
